位图(Bit-map)的原理就是使用位数组来表示某些元素是否存在，由于采用了bit为单位来存储数据，因此在存储空间方面，可以大大节省，故适用于海量数据的快速查找、判断、删除等

假设数值范围是[0,7]，有5个元素(4,7,2,5,3)。需要对这5个元素排序，如果使用位图来排序，总共需要8位，因为0~7一共8个数字，处理步骤如下：

* **设置位图状态**：遍历数组，如果包含0~7中某个元素，则设置位图8个位中相应的位为1
* **遍历位图，输出结果**：遍历位图，输出排序结果

![](../../pic/al-bitmap.png)

> * 假设有100亿个数(10,000,000,000)，如果使用int(4字节)数组实现位图，每个int可以表示32个数，那么可以使用100亿/32，大约320M个int，总共1280M的空间（1GB左右）就能存下所有100亿个数
> * **注意，由于位图每位只有0和1，所以只能表示1个元素是否存在，如果数组包含相同元素，位图没有办法记录。位图很适合在海量数值中查找某个数值是否存在。如果希望用位图记录一个数字是否多次出现，可以用2bit位图（00不存在，01存在，10出现多次，11无意义）**

### 题目

实现Bit-map，要求能够表示的最大值为10,000,000

### 解答

```c++
#define BITWORD 32
#define SHIFT 5   
#define MASK 0x1F //000..0011111(31)
#define N 10000000

int a[1+N/BITWORD];//一个int 32位（32位、64位平台）

/*将第i位设置为1，i>=0*/
void set(int i)
{
    //右移1位相当于除以2，右移SHIFT位相当于除以2^5=32，a[i >> SHIFT]相当于找到了i所在的那个int数组中的元素（32位）
    //i & MASK相当于 i % 32得到余数，1 << (i & MASK)将从右至左的(i & MASK)偏移量位设为1
    a[i >> SHIFT] |= (1 << (i & MASK));
}

/*将第i位设置为0*/
void clr(int i)
{
    //右移1位相当于除以2，右移SHIFT位相当于除以2^5=32，a[i >> SHIFT]相当于找到了i所在的那个int数组中的元素
    //1 << (i & MASK)是i的bit位偏移位置，对其取反就是该位置为0，其余位置为1
    a[i >> SHIFT] &= ~(1 << (i & MASK));
}

/*返回第i位的状态*/
int test(int i)
{
    return a[i >> SHIFT] & (1 << (i & MASK));
}
```

