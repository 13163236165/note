> 题目来源：《剑指offer》、leetcode、lintcode、hihocoder、《王道程序员求职宝典》

| 一 | 二 | 三  | 四 | 五 | 六 | 七  | 八 | 九 |
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|[数组](#array)|[字符串](#string)|[链表](#list)|[树](#tree)|[栈和队列](#stackdeque)|[数学](#math)|[图](#graph)|[海量数据](#bigdata)|[其它](#others)|

<h2 id="array"></h2>

* **一.数组**
    - *单元素查找*
        + 《剑指offer》面试题3：[数组中重复的数字](#数组中重复的数字)
        + 《剑指offer》面试题11：[旋转数组的最小数字](#旋转数组的最小数字)（`二分查找`）
        + Leetcode33：[旋转数组中查找数字](#旋转数组中查找数字)（`二分查找` `medium`）
        + 《剑指offer》面试题53(题目一)：[有序数组中查找数字的范围](#数字在排序数组中出现的次数)（`二分查找`）
        + 《剑指offer》面试题53(题目二)：[缺失的数字](#缺失的数字)（`二分查找`）
        + 《剑指offer》面试题53(题目三)：[数组中数值和下标相等的元素](#数组中数值和下标相等的元素)（`二分查找`）
        + Leetcode162：[查找数组中任一峰值的下标](#查找数组中任一峰值的下标)（`二分查找` `medium`）
        + 《剑指offer》面试题56(题目一)：[数组中只出现1次的2个数](#数组中只出现1次的2个数)（`位运算`）
        + 《剑指offer》面试题56(题目二)：[数组中唯一只出现1次的数字](#数组中唯一只出现1次的数字)（`位运算`）
        + 《剑指offer》面试题41：[数据流的中位数](#数据流的中位数)（`堆`）
    - *范围查找*
        + 《剑指offer》面试题21：[调整数组顺序使奇数位于偶数前面](#调整数组顺序使奇数位于偶数前面)（`partition`)
        + 《剑指offer》面试题39：[数组中出现次数超过一半的数字](#数组中出现次数超过一半的数字)（`partition`）
        + 《剑指offer》面试题40：[数组中最小的k个数](#数组中最小的k个数)（`partition` `海量数据`）
    - *连续子数组*
        + 《剑指offer》面试题42：[连续子数组的最大和](#连续子数组的最大和)（`动态规划`）
        + Leetcode152：[连续子数组的最大积](#连续子数组的最大积)（`动态规划` `medium`）
    - *排列组合*
        + 《剑指offer》面试题38(相关题一)：[正方体顶点上放数字](#正方体顶点上放数字)（`全排列`）
        + 《剑指offer》面试题38(相关题二)：[八皇后](#八皇后)（`全排列`）
        + Leetcode78：[不含重复元素集合的所有子集](#不含重复元素集合的所有子集)（`组合` `medium`）
    - *排序*
        + Leetcode179：[将一组数拼接成最大数字](#将一组数拼接成最大数字)（`medium`）
    - *满足要求的元素对*
        + 《剑指offer》面试题51：[数组中的逆序对](#数组中的逆序对)（`分治归并`）
        + Leetcode315：[计算右侧小于当前元素的个数](#计算右侧小于当前元素的个数)（`分治归并` `BST` `hard`）
    - *二维数组*
        + 《剑指offer》面试题4：[二维数组中的查找](#二维数组中的查找)
        + 《剑指offer》面试题66：[构建乘积数组](#构建乘积数组)

<h2 id="string"></h2>

* **二.字符串**
    - *字符串匹配*
        + Leetcode10：[正则表达式匹配](#正则表达式匹配)（`动态规划` `hard`）
        + Leetcode44：[通配符匹配](#通配符匹配)（`动态规划` `hard`）
    - *公共子串和公共子序列*
        + Lintcode77：[两个字符串的最长公共子序列](#两个字符串的最长公共子序列)（`动态规划` `medium`）
        + Lintcode79：[两个字符串的最长公共子串](#两个字符串的最长公共子串)（`动态规划` `medium`）
    - *字符串与数字*
        + 《剑指offer》面试题20：[判断字符串是否表示一个数值](#判断字符串是否表示一个数值)（`鲁棒性`）
        + 《剑指offer》面试题67：[把字符串转换成整数](#把字符串转换成整数)（`鲁棒性`）
    - *字符查找*
        + 《剑指offer》面试题50(题目一)：[字符串中第一个只出现一次的字符](#字符串中第一个只出现一次的字符)（`哈希表`）
        + 《剑指offer》面试题50(题目二)：[字符流中第一个只出现一次的字符](#字符流中第一个只出现一次的字符)（`哈希表`）
    - *翻转*
        + 《剑指offer》面试题58(题目一)：[翻转单词顺序](#翻转单词顺序)
        + 《剑指offer》面试题58(题目二)：[左旋转字符串](#左旋转字符串)
    - *排列组合*
        + 《剑指offer》面试题38：[字符串的排列](#字符串的排列)（`排列`）
        + 《剑指offer》面试题38(扩展)：[求字符的所有组合](#求字符的所有组合)（`组合`）
    - *其它*
        + 《剑指offer》面试题5：[替换空格](#替换空格)

<h2 id="list"></h2>

* **三.链表**
    - *遍历*
        + 《剑指offer》面试题6：[从尾到头打印链表](#从尾到头打印链表)（`栈`）
        + 《剑指offer》面试题22：[链表中倒数第k个节点](#链表中倒数第k个节点)（`双指针`）
        + 《剑指offer》面试题22(相关题)：[链表的中间节点](#链表的中间节点)（`双指针`）
        + 《剑指offer》面试题23：[链表中环的入口节点](#链表中环的入口节点)（`双指针`）
    - *节点删除*
        + 《剑指offer》面试题18(题目一)：[删除链表中的节点](#删除链表中的节点)
        + Leetcode83：删除有序链表中：[删除有序链表中的冗余节点](#删除有序链表中的冗余节点)（`easy`）
        + 《剑指offer》面试题18(题目二)：[删除有序链表中重复的节点](#删除有序链表中重复的节点)
        + 面试：实现双链表节点删除函数
    - *单链表处理*
        + 《剑指offer》面试题24：[反转链表](#反转链表)（`栈`）
        + 《剑指offer》面试题35：[复杂链表的复制](#复杂链表的复制)
    - *多链表处理*
        + 《剑指offer》面试题25：[合并两个有序链表](#合并两个有序链表)
        + 《剑指offer》面试题52：[两个链表的第一个公共节点](#两个链表的第一个公共节点)（`双指针`）

<h2 id="tree"></h2>

* **四.树**
    - *遍历*
        + 《剑指offer》面试题7：[重建二叉树](#重建二叉树)（`前序` `中序`）
        + 《剑指offer》面试题8：[中序遍历的下一个节点](#中序遍历的下一个节点)（`中序`）
        + 《剑指offer》面试题26：[树的子结构](#树的子结构)（`前序`）
        + 《剑指offer》面试题37：[序列化二叉树](#序列化二叉树)（`前序`）
        + Leetcode98：[判断一棵二叉树是否是BST](#判断一棵二叉树是否是bst)（`BST` `中序` `medium`）
        + 《剑指offer》面试题33：[BST的后序遍历序列](#bst的后序遍历序列)（`BST` `后序`）
        + 《剑指offer》面试题36：[BST转双链表](#bst转双链表)（`BST` `中序` `双链表`）
        + Leetcode109：[单链表转BST](#单链表转bst)（`BST` `中序` `单链表` `medium`）
        + 《剑指offer》面试题54：[BST第k小的节点](#bst第k小的节点)（`BST` `中序`）
        + 《剑指offer》面试题32(题目一)：[按层不分行输出二叉树](#按层不分行输出二叉树)（`BFS`）
        + 《剑指offer》面试题32(题目二)：[按层分行输出二叉树](#按层分行输出二叉树)（`BFS`）
        + 《剑指offer》面试题32(题目三)：[之字形打印二叉树](#之字形打印二叉树)（`BFS` `栈`）
    - *对称二叉树*
        + 《剑指offer》面试题27：[二叉树的镜像](#二叉树的镜像)（`递归` `迭代`）
        + 《剑指offer》面试题28：[对称的二叉树](#对称的二叉树)（`递归` `迭代`）
    - *路径*
        + 《剑指offer》面试题34：[二叉树中和为某一值的路径](#二叉树中和为某一值的路径)（`回溯`）
        + Leetcode124：[二叉树的最大路径和](#二叉树的最大路径和)（`动态规划` `后序` `hard`）
    - *深度*
        + 《剑指offer》面试题55(题目一)：[二叉树的深度](#二叉树的深度)（`递归`）
        + 《剑指offer》面试题55(题目二)：[平衡二叉树AVL](#平衡二叉树avl)（`后序`）
    - *公共祖先*
        + 《剑指offer》面试题68：[两个节点的最低公共祖先](#两个节点的最低公共祖先)

<h2 id="stackdeque"></h2>

* **五.栈和队列**
    - *设计*
        + 《剑指offer》面试题9：[用两个栈实现队列](#用两个栈实现队列)（`栈` `队列`）
        + 《剑指offer》面试题9(相关题)：[用两个队列实现栈](#用两个队列实现栈)（`栈` `队列`）
        + 《剑指offer》面试题30：[包含min函数的栈](#包含min函数的栈)（`栈`）
        + 《剑指offer》面试题59(题目二)：[包含max函数的队列](#包含max函数的队列)（`队列`）
    - *其它*
        + 《剑指offer》面试题31：[栈的压入弹出序列](#栈的压入弹出序列)（`栈`）
        + 《剑指offer》面试题59(题目一)：[滑动窗口的最大值](#滑动窗口的最大值)（`队列`）

<h2 id="math"></h2>

* **六.数学**
    - *斐波那契数列*
        + 《剑指offer》面试题10(题目一)：[斐波那契数列](#斐波那契数列)（`动态规划`）
        + 《剑指offer》面试题10(题目二)：[跳台阶](#跳台阶)（`动态规划`）
        + 《剑指offer》面试题10(题目三)：[变态跳台阶](#变态跳台阶)（`动态规划`）
        + 《剑指offer》面试题10(题目四)：[矩形覆盖](#矩形覆盖)（`动态规划`）
    - *进制*
        + 《剑指offer》面试题15：[二进制中1的个数](#二进制中1的个数)（`位运算`）
    - *鲁棒性*
        + 《剑指offer》面试题16：[数值的整数次方](#数值的整数次方)（`位运算`）
        + Leetcode166：[求分数的值](#求分数的值)（`medium`）
    - *找规律*
        + 《剑指offer》面试题43：[整数1~n中1出现的次数](#整数1n中1出现的次数)
    - *特殊数字*
        + 《剑指offer》面试题49：[丑数](#丑数)
    - *条件限制*
        + 《剑指offer》面试题64：[求1~n的和](#求1n的和)
        + 《剑指offer》面试题65：[不用加减乘除做加法](#不用加减乘除做加法)（`位运算`）
        + Leetcode29：[不用乘除取模实现整数除法](#不用乘除取模实现整数除法)（`位运算` `medium`）

<h2 id="graph"></h2>

* **七.图**

<h2 id="bigdata"></h2>

* **八.海量数据**

<h2 id="others"></h2>

* **九.其它**

<br>
<br>
<br>
<br>
<br>
<br>
<br>

## 数组中重复的数字

[OJ链接](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个长度为n的数组里的所有数字都在`0~n-1`的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字

例如，如果输入长度为7的数组`{2,3,1,0,2,5,3}`，那么对应的输出是第一个重复的数字`2`

### 解答

1. **排序**（时间:O(nlogn)，空间:O(1)：先排序，然后遍历数组找到第一个重复的数字即可
2. **哈希表**（时间:O(n)，空间:O(n)）：扫描数组，使用哈希表统计每个数字出现的次数，当统计到一个以前出现过的数字时，找到重复
3. **交换**（时间:O(n)，空间:O(1)）：如果位置i的数字m不等于i，与位置m的数字比较
    - 如果位置m的数字不等于m，那么交换，直到位置i的数字等于i或位置m的数字等于m
    - 如果位置m的数字等于m，说明数字m存在重复
    ```c++
    class Solution {
    public:
        // Parameters:
        //        numbers:     an array of integers
        //        length:      the length of array numbers
        //        duplication: (Output) the duplicated number in the array number
        // Return value:       true if the input is valid, and there are some duplications in the array number
        //                     otherwise false
        bool duplicate(int numbers[], int length, int* duplication) {
            if(length <= 2)
                return false;
            for(int i = 0;i < length;i++){
                while(numbers[i] != i){
                    int m = numbers[i];
                    if(m < 0 || m >= length)
                        return false;
                    if(m == numbers[m]){
                        *duplication = m;
                        return true;
                    }
                    numbers[i] = numbers[m];
                    numbers[m] = m;
                }
            }
            return false;
        }
    };
    ```
4. **位图**：当数据量特别大时可以使用位图，相比于哈希表，更节省空间

<br>
<br>

## 旋转数组的最小数字

[OJ链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为`1`

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`

### 解答

```c++
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size() == 0)
            return 0;
        if(rotateArray.size() == 1)
            return rotateArray[0];
        
        int sz = rotateArray.size();
        int l = 0,r = sz - 1;
        //如果没有旋转，不会进入循环，这样初始化会直接返回最左边元素
        int mid = l;
        while(rotateArray[r] <= rotateArray[l]){
            if(r - l == 1){
                mid = r;
                break;
            }
            mid = (l + r) >> 1;
            //如果首尾元素以及中间元素相等，那么没有办法判断中间元素到底是在左半部分还是右半部分，这时只能用顺序查找
            if(rotateArray[l] == rotateArray[r] && rotateArray[l] == rotateArray[mid]){
                int min = rotateArray[0];
                for(int i = 1;i < sz;i++){
                    if(rotateArray[i] < min) 
                        min = rotateArray[i];
                }
                return min;
            }
            if(rotateArray[mid] >= rotateArray[l])
                l = mid;
            else if(rotateArray[mid] <= rotateArray[r])
                r = mid;
        }
        return rotateArray[mid];
    }
};
```

<br>
<br>

## 旋转数组中查找数字

[OJ链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]`` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 解答

根据mid位置的值判断mid是在左半部分还是右半部分

* 如果在左半部分（说明mid位置的值比end位置的值大）
    * 当target大于mid位置的值或target小于等于end位置的值时，继续在右边查找
    * 否则，在左边查找
+ 如果在右半部分（说明mid位置的值比end位置的值小）
    * 当target大于mid位置的值并且target小于end位置的值时，才能在右边查找
    * 否则，在左边查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return -1;
        
        int begin = 0 , end = nums.size() - 1;
        int mid;
        while(begin <= end){
            mid = (begin + end) / 2;
            if(nums[mid] > nums[end]){//mid在左边
                if(nums[mid] == target)  return mid;
                else if(nums[mid] < target || target <= nums[end])    begin = mid + 1;
                else    end = mid - 1;
            }
            else{//mid在右边
                if(nums[mid] == target) return mid;
                else if(nums[mid] < target && target <= nums[end])  begin = mid + 1;
                else end = mid - 1;
            }
        }
        return -1;
    }
};
```

<br>
<br>

## 有序数组中查找数字的范围

[OJ链接](https://leetcode.com/problems/search-for-a-range/description/)

统计一个数字在排序数组中出现的次数

### 解答

使用二分查找，分别找到数字的下边界和上边界

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = searchRangel(nums,target);
        int r = searchRanger(nums,target);
        
        vector<int> v;
        v.push_back(l);
        v.push_back(r);
        return v;
    }
    
    int searchRangel(const vector<int> &nums,int target)
    {
        int l = 0,r = nums.size() - 1;
        int mid;
        
        while(l <= r){
            mid = (l + r) / 2;
            if(nums[mid] == target){
                if(mid == 0 || nums[mid - 1] != nums[mid])  return mid;
                else   r = mid - 1;
            }
            else if(nums[mid] > target) r = mid - 1;
            else    l = mid + 1;
        }
        
        return -1;
    }
    
    int searchRanger(const vector<int> &nums,int target)
    {
        int l = 0,r = nums.size() - 1;
        int mid,end = r;
        
        while(l <= r){
            mid = (l + r) / 2;
            if(nums[mid] == target){
                if(mid == end || nums[mid + 1] != nums[mid])  return mid;
                else   l = mid + 1;
            }
            else if(nums[mid] > target) r = mid - 1;
            else    l = mid + 1;
        }
        
        return -1;
    }
};
```

<br>
<br>

## 缺失的数字

一个长度为`n-1`的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围`0~n-1`之内。在范围`0~n-1`内的`n`个数字中有且只有一个数字不在该数组中，请找出这个数字

### 解答

数组中开始的一些数字与它们的下标相同，如果m不在数组中，则下标m位置的元素是m+1...问题转换为找到数组中下标和元素值不相等的第一个元素

<br>
<br>

## 数组中数值和下标相等的元素

假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组`{-3, -1, 1, 3, 5}`中，数字3和它的下标相等

<br>
<br>

## 查找数组中任一峰值的下标

[OJ链接](https://leetcode.com/problems/find-peak-element/description/)

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

示例 1:

```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```

示例 2:

```
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

说明:

你的解法应该是 O(logN) 时间复杂度的

### 解答

#### 1）线性查找

遍历数组，对于每个元素，如果该元素的前一元素和后一元素都小于该元素，那么该元素是一个峰值，返回

* 时间复杂度：O(n)
* 空间复杂度：O(1)

#### 2）二分查找

* 如果中间元素比右边的元素小，意味着当前处于一个“升序”中，那么右边(不含当前元素)将会出现一个峰值
* 如果中间元素比右边的元素大，意味着当前处于一个“降序”中，那么左边(包含当前元素)将会出现一个峰值
* 如果中间元素等于右边的元素，那么无法减小区间（所以题目给出了nums[i]不等于nums[i+1]）

使用上述判断一直减小区间，直到区间只有1个元素

* 时间复杂度：O(logn)
* 空间复杂度：O(1)

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int ret = -1;
        int l = 0,r = nums.size() - 1,mid;
        while(l < r){
            mid = (l + r) >> 1;
            if(nums[mid] < nums[mid + 1])
                l = mid + 1;
            else if(nums[mid] > nums[mid + 1])
                r = mid;
            //假设输入合法，如果nums[mid] == nums[mid+1]会无限循环
            //为了代码的简洁性暂时不处理这种情况
        }
        return l == r ? l : -1;
    }
};
```

<br>
<br>

## 数组中只出现1次的2个数

[OJ链接](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字

### 解答

可以先考虑如果只有1个数字出现1次，其余都2次，怎么找：

*  对所有数字异或，由于异或满足结合律交换律，结果就是所要查找的数字

对于存在2个数字出现1次的数字:

* 所有数字异或结果为这两个数字的异或值，如果能将数组分为2部分，每个数字属于其中一部分，则能求出这两个数字。可以找到这两个数字异或结果中第一个为1的位，根据该位将数组分成2个数组

```c++
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        int num1xornum2 = 0;
        int sz = data.size();
        
        for(int i = 0;i < sz;i++)
            num1xornum2 ^= data[i];
        
        int idx = 0;
        while(((num1xornum2 & 1) == 0) && (idx < 32)){
            idx++;
            num1xornum2 = num1xornum2 >> 1;
        }
        
        *num1 = 0,*num2 = 0;
        for(int i = 0;i < sz;i++){
            if(isBit(data[i],idx))
                *num1 ^= data[i];
            else
                *num2 ^= data[i];
        } 
    }
    
    bool isBit(int num,int idx){
        while(idx){
            num = num >> 1;
            idx--;
        }
        return (num & 1);
    }
    
    bool checknum(vector<int> &data,int num1,int num2){
        int count1 = 0,count2 = 0,sz = data.size();
        for(int i = 0;i < sz;i++){
            if(data[i] == num1)
                count1++;
            if(data[i] == num2)
                count2++;
        }
        
        return (count1 == 1) && (count2 == 1);
    }
};
```

<br>
<br>

## 数组中唯一只出现1次的数字

在一个数组中除一个数字只出现一次之外，其他数字都出现了3次。请找出那个只出现一次的数字

### 解答

如果其余数字都出现2次，则使用异或很好解决，但是这里是3次，所以无法使用异或；但是还是可以沿用位运算的思路，如果一个数字出现3次，其二进制表示的每一位也出现3次，把所有出现3次的数字的二进制表示的每一位都分别加起来，每一位的和都能被3整除。我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么只出现一次的数字二进制中对应的那一位是0，否则是1

<br>
<br>

## 数据流的中位数

[OJ链接](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值

### 解答

使用2个堆，每个堆保存一半的元素。最大堆保存较小一半的数，最小堆保存较大一半的数，使用一个变量判断当前读入元素的个数，根据元素个数的奇偶来求中位数

```c++
class Solution {
public:
    void Insert(int num)
    {
        if(index % 2 == 0){
            if(max.size() > 0 && num < max[0]){
                max.push_back(num);
                push_heap(max.begin(),max.end(),less<int>());
                
                num = max[0];
                pop_heap(max.begin(),max.end(),less<int>());
                max.pop_back();
            } 
            min.push_back(num);
            push_heap(min.begin(),min.end(),greater<int>());
        }
        else{
            if(min.size() > 0 && num > min[0]){
                min.push_back(num);
                push_heap(min.begin(),min.end(),greater<int>());
                
                num = min[0];
                
                pop_heap(min.begin(),min.end(),greater<int>());
                min.pop_back();
            }
            max.push_back(num);
            push_heap(max.begin(),max.end(),less<int>());
        }
        
        index++;
    }

    double GetMedian()
    {
        double median = 0;
        if(index % 2 == 1){
            median = min[0];
        }
        else{
            median = (min[0] + max[0])/(2.0);
        }
        return median;
    }

private:
    vector<int> max;
    vector<int> min;
    int index = 0;
};
```

<br>
<br>

## 调整数组顺序使奇数位于偶数前面

[OJ链接](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

> 可以将判断元素是否满足条件的表达式设计为函数指针以满足扩展性：1）负数位于前面，正数位于后面；3）能被3整除的位于前面，不能的位于后面

### 解答

1. 基于快排的partition方法
2. 如果要求保证奇数的原有相对顺序、偶数的原有相对顺序，那么使用一个临时数组保存原数组，然后统计奇数或偶数元素的个数，使用两个指针(下标)分别指向奇数和偶数的起始位置，遍历临时数组如果是奇数则在原数组中记录并移动奇数指针，如果是偶数...

```c++
class Solution {
public:
    /*
     * 剑指offer中的题没有要求“必须保证原有顺序”
     * 如果要保证顺序，在i后面的j位置找到一个奇数时，需要把[i,...,j-1]的元素往后移动，然后把j交换到i位置，这样复杂度为O(n^2)
     * 则使用插入排序编码更简洁，如果要实现O(n)时间复杂度，必须使用一个辅助数组（空间换时间）
     * 总的来说，要求“必须保证原有顺序”比起不要求时，整个解法可以很不一样
     */
    void reOrderArray(vector<int> &array) {
        vector<int> tp = array;
        int oddcount = 0;
        for(int i : tp)
            if (i % 2 == 1)
                oddcount++;
        int m = 0,n = oddcount;
        for(int i : tp){
            if(i % 2 == 1)
                array[m++] = i;
            else
                array[n++] = i;
        }
    }
};
```

<br>
<br>

## 数组中出现次数超过一半的数字

[OJ链接](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字

例如输入一个长度为9的数组`{1,2,3,2,2,2,5,4,2}`。由于数字`2`在数组中出现了`5`次，超过数组长度的一半，因此输出`2`

如果不存在则输出`0`

### 解答

1. 基于partition的方法
2. 该数字出现的次数超过其它数字出现的次数之和（因此，考虑使用2个变量，一个保存数字，一个保存次数。当遍历到下一个数字时，如果下一数字和之前保存的数字相同，则次数加1，如果下一数字和之前保存的数字不同，则次数减1。如果次数为0，则需保存下一个数字，并把次数设为1，最后一次把次数设为1时对应的数字就是结果）​

```c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.size() == 0)
            return 0;
        
        int count = 0;
        int res = numbers[0];
        for(int e : numbers){
            if(e == res)
                count++;
            else{
                if(count == 0)
                    res = e;
                else
                    count--;
            }
        }
        
        count = 0;
        for(int i = 0;i < numbers.size();i++){
            if(numbers[i] == res)
                count++;
        }
        if(count * 2 <= numbers.size())
            return 0;
        return res;
    }
};
```

<br>
<br>

## 数组中最小的k个数

[OJ链接](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入`n`个整数，找出其中最小的`K`个数。例如输入`4,5,1,6,2,7,3,8`这8个数字，则最小的`4`个数字是`1,2,3,4`

### 解答

1. 基于partition函数的方法（不适合海量数据）
2. 使用容器(最大堆)存储最小的k个数，遍历数组，当有更小的数时替换掉原容器中最大的（适合处理海量数据，即数组不能一次载入内存）​

> 这个题改成求(从小到大)第k大的数也是这两种方法

<br>
<br>

## 连续子数组的最大和

[OJ链接](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 解答

令sum[i]表示所有以位置i的元素结尾的连续子数组的最大和，状态转移方程如下：

* 当 `sum[i] <= 0` 时，`sum[i+1] = array[i + 1]`
* 当 `sum[i] > 0` 时，`sum[i+1] = sum[i] + array[i + 1]`

那么连续子数组的最大和，就是`max{sum[0],sum[1],...,sum[n-1]}`

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.size() == 0)   return 0;

        int sum = array[0],res = array[0];
        int sz = array.size();
        for(int i = 1;i < sz;i++){
            if(sum > 0)    sum += array[i];
            else           sum = array[i];
            if(sum > res)  res = sum;
        }
        
        return res;
    }
};
```

<br>
<br>

## 连续子数组的最大积

[OJ链接](https://leetcode.com/problems/maximum-product-subarray/description/)

给定一个整数数组 `nums` ，找出乘积最大的连续子数组（该数组至少包含一个数）

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是连续子数组。
```

### 解答

假设`max_local[i]`表示以`nums[i]`结尾的连续子数组的最大积，如果能求出所有`max_local`，那么最大者就是答案

现在看怎么求`max_local[i]`：

* 如果`max_local[i - 1]`为`0`
    - 当`nums[i]`大于等于`0`时，`max_local[i] = nums[i]`，与前面的子数组无关
    - 当`nums[i]`小于`0`时，`max_local[i] = 0`
* 否则，如果`nums[i]`与`max_local[i - 1]`符号相同，那么`max_local[i] = nums[i] * max_local[i - 1]`，此时将前面的连续子数组并入
* 否则，如果`nums[i]`与`max_local[i - 1]`符号不同，那么`nums[i] * max_local[i - 1]`是以`nums[i]`结尾的连续子数组的最小积，设为`min_local[i]`，如果知道`min_local[i - 1]`，那么就能求出`max_local[i]`：`max_local[i] = min_local[i - 1] * nums[i]`

因此，要求出max_local[i]，同时需要维护连续子数组的最小积——`min_local`数组，对上面的分析进行总结：因为`nums[i]`可能与`max_local[i - 1]`同号，可能异号，`max_local[i - 1]`也可能为`0`。所以`max_local[i]`取决于3个值：`max_local[i - 1]*nums[i]`、`min_local[i - 1]*nums[i]`、`nums[i]`（隐含了状态转移方程）

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.empty())    return 0;
        
        int max_global = nums[0];
        int max_local = nums[0],min_local = nums[0];
        
        for(int i = 1;i < nums.size();i++){
            int _max = max(max_local * nums[i],min_local * nums[i],nums[i]);
            int _min = min(max_local * nums[i],min_local * nums[i],nums[i]);
            max_local = _max;
            min_local = _min;
            if(max_local > max_global)  max_global = max_local;
        }
        
        return max_global;
    }
private:
    int max(int num1,int num2,int num3){
        return num1 > num2 ? (num1 > num3 ? num1 : num3) : (num2 > num3 ? num2 : num3); 
    }
    
    int min(int num1,int num2,int num3){
        return num1 < num2 ? (num1 < num3 ? num1 : num3) : (num2 < num3 ? num2 : num3);
    }
};
```

<br>
<br>

## 正方体顶点上放数字 

输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等

### 解答

相当于先得到`a1、a2、a3、a4、a5、a6、a7`和`a8`这`8`个数字的所有排列，然后判断有没有某一个排列符合题目给定的条件，即`a1+a2+a3+a4=a5+a6+a7+a8`，`a1+a3+a5+a7=a2+a4+a6+a8`，并且`a1+a2+a5+a6=a3+a4+a7+a8`

<br>
<br>

## 八皇后

在8\*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。问总共有多少种符合条件的摆法？

### 解答

由于`8`个皇后的任意两个不能处在同一行，那么肯定是每一个皇后占据一行。于是可以定义一个数组`ColumnIndex[8]`，数组中第`i`个数字表示位于第`i`行的皇后的列号。先把数组`ColumnIndex`的`8`个数字分别用`0~7`初始化，然后对数组`ColumnIndex`进行全排列。因为用不同的数字初始化了数组，所以任意两个皇后肯定不同列。只需判断每一个排列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标`i`和`j`，是否有`i-j==ColumnIndex[i]-ColumnIndex[j]`或者`j-i==ColumnIndex[i]-ColumnIndex[j]`

<br>
<br>

## 不含重复元素集合的所有子集

[OJ链接](https://leetcode.com/problems/subsets/description/)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）

说明：解集不能包含重复的子集

示例:

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 解答

对于每个元素，可以选择要或者不要

* 如果要，子集等于该元素加上剩余元素的所有子集
* 如果不要，子集等于剩余元素的所有子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> subset;
        vector<vector<int>> res;
        subsets(nums,0,res,subset);
        return res;
    }
    
private:
    void subsets(const vector<int> &nums,int idx,vector<vector<int>> &res,vector<int> subset){
        if(idx < 0) return;
        else if(idx == nums.size()){
            res.push_back(subset);
            return;
        }
        
        subset.push_back(nums[idx]);
        subsets(nums,idx + 1,res,subset);
        subset.pop_back();
        subsets(nums,idx + 1,res,subset);
    }
};
```

<br>
<br>

## 将一组数拼接成最大数字

* 排成最大数字：[OJ链接](https://leetcode.com/problems/largest-number/description/)（Leetcode）
* 排成最小数字：[OJ链接](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)（牛客网）

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

示例 1:

```
输入: [10,2]
输出: 210
```

示例 2:

```
输入: [3,30,34,5,9]
输出: 9534330
```

说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数

### 解答

给出数字`m`和`n`，需要确定一个规则判断`m`和`n`哪个应该排在前面，如果`mn>nm`，那么`m`应该排在`n`前面，此时定义`m>n`...

根据这个规则对数组中的数字进行排序，排序后的序列就是最大的数；

#### 1）使用函数

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),comp);
        
        //处理所有元素都是0的情况
        if(!nums.empty() && nums[0] == 0)   return "0";
        
        string res = "";
        for(int num : nums) res = res + to_string(num);
        
        return res;
    }
private:
    static bool comp(int num1,int num2){
        string s1 = to_string(num1) + to_string(num2);
        string s2 = to_string(num2) + to_string(num1);
        
        return s2 < s1;
    }
};
```

#### 2）使用lambda

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[](const int &num1,const int &num2){
            return to_string(num2) + to_string(num1) < to_string(num1) + to_string(num2);
        });
        
        //处理所有元素都是0的情况
        if(!nums.empty() && nums[0] == 0)   return "0";
        
        string res = "";
        for(int num : nums) res = res + to_string(num);
        
        return res;
    }
};
```

<br>
<br>

## 数组中的逆序对

[OJ链接](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数`P`。并将`P`对`1000000007`取模的结果输出。 即输出`P%1000000007`

### 解答

1. 遍历每个元素，在这个元素的后面剩余元素中查找比该元素小的元素，每找到一个组成一个逆序对；（O(n^2)）
2. 基于归并排序的方法；（O(nlogn)）

```c++
class Solution {
public:
    int InversePairs(vector<int> data) {
       if(data.size() < 2)
           return 0;
        
        vector<int> tp = data;
        int count = 0,sz = data.size();
        InversePairs(data,tp,count,0,sz - 1);
        
        return count;
    }
    
    void InversePairs(vector<int> &data,vector<int> &tp,int &count,int l,int r){
        if(l >= r)
            return;
        
        int mid = (l + r)/2;
        InversePairs(data,tp,count,l,mid);
        InversePairs(data,tp,count,mid + 1,r);
        
        //归并
        int idx1 = mid,idx2 = r,curr = r;
        while(idx1 >= l && idx2 >= mid + 1){
            if(data[idx1] > data[idx2]){//有逆序对
                count = (idx2 - mid + count) % 1000000007;
                tp[curr--] = data[idx1--];
            }
            else{
                tp[curr--] = data[idx2--];
            }
        }
        while(idx1 >= l)
            tp[curr--] = data[idx1--];
        while(idx2 >= mid + 1)
            tp[curr--] = data[idx2--];
        
        for(int i = l;i <= r;i++)
            data[i] = tp[i];
    }
};
```

<br>
<br>

## 计算右侧小于当前元素的个数

[OJ链接](https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/)

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

示例:

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

### 解答

#### 1）归并(分治)

其实就是类似[求逆序对](#数组中的逆序对)的方法，不过求逆序对这个题是求出逆序对的总数即可，但是这里实际是求数组中每个元素和其后元素的数构成多少个逆序对，所以会复杂一些，但是方法一样

假设有2个数组num1（假设下标为l1-r1）和num2（假设下标为l2-r2），满足下列性质：

* num1和num2已经按照降序排好序
* l1 <= r1 < l2 <= r2

因为num1中的每个元素都在num2的前面，因此很好统计有多少个逆序对，归并过程如下：

* 对于num1中的元素m和num2中的元素n，有：
    - 如果m大于n，那么m元素的逆序对增加的数量为num2中n及n以后所有元素的数量，然后继续处理num1中m后方的元素
    - 如果m小于等于n，m及num1中m后方的元素，都不可能与n构成逆序对，因此处理num2中n后方的元素
* 上面的过程可以统计出逆序对，但是在该次归并后，下一次归并时，我们需要保证新的更大的数组依然满足降序的顺序，因此在统计逆序对的过程中需要进行归并排序
* 最后一个问题是，在统计逆序对的过程中，如果m比n大，那么需要增加m的逆序对的数量，但是在归并过程中，m的位置可能不断发生变化，同时数组中可能包含相同的值，即多个m，那么如何根据m定位到需要增加逆序对的位置？答案是使用下标，在归并和排序的过程中，使用的是一个下标数组idx，根据这个数组可以定位到元素在最初数组中的位置，同时，即使不断移动，也能索引到其值

```c++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int> idx;
        for(int i = 0;i < nums.size();i++)  idx.push_back(i);
        vector<int> res(nums.size(),0);
        vector<int> tmp(nums.size(),0);
        countSmallerCore(nums,idx,tmp,res,0,nums.size() - 1);
        return res;
    }
private:
    void countSmallerCore(vector<int> &nums,vector<int> &idx,vector<int> &tmp,vector<int> &res,int l,int r){
        if(l >= r)  return;

        int mid = (l + r) >> 1;
        countSmallerCore(nums,idx,tmp,res,l,mid);
        countSmallerCore(nums,idx,tmp,res,mid + 1,r);
        merge(nums,idx,tmp,res,l,mid,mid + 1,r);
    }

    void merge(vector<int> &nums,vector<int> &idx,vector<int> &tmp,vector<int> &res,int l1,int r1,int l2,int r2){
        int p1 = l1,p2 = l2,p = l1;
        while(p1 <= r1 && p2 <= r2){
            if(nums[idx[p1]] > nums[idx[p2]]){
                res[idx[p1]] += r2 - p2 + 1;
                tmp[p++] = idx[p1++];
            }
            else
                tmp[p++] = idx[p2++];
        }
        while(p1 <= r1) tmp[p++] = idx[p1++];
        while(p2 <= r2) tmp[p++] = idx[p2++];

        p = l1;
        while(p <= r2){
            idx[p] = tmp[p];
            p++;
        }
    }

};
```

#### 2）BST

假设从数组右边往左构建BST，每当遍历到一个元素时，其右边节点已经构成了一棵BST，对于当前节点，如果能在将其插入BST的过程中同时得到BST中小于该元素的节点个数，那么每个元素就能实现O(logn)的查找，总的时间复杂度就是O(nlogn)

为了能够在BST中快速得到比新插入元素小的节点个数，肯定需要在节点中维护除节点值以外的其它信息。因为数组中可能包含相同元素，那么BST节点中添加一个`count`变量统计相同元素的个数，那么再添加一个`left_count`变量表示BST中比当前节点值小的节点总数（**这种假设是一种全局性质**），假设这样行的通，那么只要找到新节点插入点的父节点，那么就可以根据父节点判断比新值小的元素有多少个

但是这样行不通，因为在插入节点时，需要更新BST中已有节点的`left_count`，如果`left_count`表示BST中比当前节点值小的节点总数，那么无法实现O(logn)的查找，考虑如下例子：

```
       a
      / \
     b   c 
```


* 如果新节点比a小，如果`left_count`表示BST中比当前节点值小的节点总数，那么在新节点插入时，需要递增a节点的`left_count`
* 如果新节点比a大，a节点的`left_count`不变，继续往a节点的右子树处理

注意，问题出在新节点比a小时！此时只能更新a，如果`left_count`表示BST中比当前节点值小的节点总数，那么所有a节点右子树中的节点都应该递增其`left_count`

那么到底应该赋予`left_count`什么样的意义？现在不管a节点的左子树和右子树长什么样，并且假设a是BST中任意节点。每当一个节点需要插入a节点的左边时，比a节点小的节点都加1，这是肯定没问题的。所以我们**只能保证一种局部性质**，即**`left_count`表示该节点左子树的节点总数**

那么如果`left_count`表示该节点左子树的节点总数，有没有办法在插入一个节点时获取整棵BST中比新节点小的节点总是？答案是肯定的，从根节点开始遍历，查找新节点的插入位置：

* 如果新节点大于某个节点a，那么小于新节点的节点个数就增加`a->left_count+a->count`
* 如果新节点等于某个节点a，那么小于新节点的节点个数就增加`a->left_count`
* 如果新节点小于某个节点a，此时只能知道新节点在a的左子树中，但是无法知道a的左子树中有多少节点小于新节点，所以暂时无法得出应该增加多少，因此增加`0`

```c++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        if(nums.size() <= 0)    return vector<int>();
        
        vector<int> res;
        BSTNode *root = new BSTNode(nums.back());
        res.push_back(0);
        for(int i = nums.size() - 2;i >= 0;i--)
            res.push_back(insertBSTNode(root,nums[i]));
        
        delete root;
    
        reverse(res.begin(),res.end());
        
        return res;    
    }
private:
    struct BSTNode{
        int val;        //节点的值
        int count;      //相同值的个数
        int left_count; //左子树节点的个数
        BSTNode *left;
        BSTNode *right;
        BSTNode(int v) : val(v) , count(1) , left_count(0) , left(NULL) , right(NULL) {}
        ~BSTNode() {delete left;delete right;}
    };

    int insertBSTNode(BSTNode *root,int val){
        int res = 0;
        BSTNode *p = root,*pp;
        while(p){
            if(val < p->val){
                (p->left_count)++;
                res += 0;
                pp = p;
                p = p->left;
            }
            else if(val > p->val){
                res += p->count + p->left_count;
                pp = p;
                p = p->right;
            }
            else{
                (p->count)++;
                res += p->left_count;
                break;
            }
        }
        BSTNode *node = p;
        if(!p){ //说明不是一个以前出现过的值，因此需要插入
            node = new BSTNode(val);
            if(val < pp->val)   pp->left = node;
            else    pp->right = node;
        }
        return res;
    }
};
```

#### 3）树状数组

* [树状数组(Binary Index Tree)介绍](https://www.youtube.com/watch?v=WbafSgetDDk)
* [树状数组的解法](https://www.youtube.com/watch?v=2SVLYsq5W8M)

```c++
// Author: Huahua
// Runnning time: 32 ms
// Time complexity: O(nlogn)
// Space complexity: O(k), k is the number unique elements
class FenwickTree {    
public:
    FenwickTree(int n): sums_(n + 1, 0) {}
    
    void update(int i, int delta) {
        while (i < sums_.size()) {
            sums_[i] += delta;
            i += lowbit(i);
        }
    }
    
    int query(int i) const {        
        int sum = 0;
        while (i > 0) {
            sum += sums_[i];
            i -= lowbit(i);
        }
        return sum;
    }
private:
    static inline int lowbit(int x) { return x & (-x); }
    vector<int> sums_;
};
 
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        // Sort the unique numbers
        set<int> sorted(nums.begin(), nums.end());
        // Map the number to its rank
        unordered_map<int, int> ranks;
        int rank = 0;
        for (const int num : sorted)
            ranks[num] = ++rank;
        
        vector<int> ans;
        FenwickTree tree(ranks.size());
        // Scan the numbers in reversed order
        for (int i = nums.size() - 1; i >= 0; --i) {
            // Chechk how many numbers are smaller than the current number.
            ans.push_back(tree.query(ranks[nums[i]] - 1));
            // Increse the count of the rank of current number.
            tree.update(ranks[nums[i]], 1);
        }
        
        std::reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

<br>
<br>

## 二维数组中的查找

[OJ链接](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

### 解答

选取右上角或左下角的元素，以左下角为例：

* 如果左下角元素大于查找元素，则删除所在行
* 如果左上角元素小于查找元素，则删除所在列

```c++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int rows = array.size();
        int columns = array[0].size();
         
        int r = rows - 1,c = 0;
        while(r >= 0 && c < columns){
            if(array[r][c] < target)
                c++;
            else if(array[r][c] > target)
                r--;
            else
                return true;
        }
         
        return false;
    }
};
```

<br>
<br>

## 构建乘积数组

[OJ链接](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一个数组`A[0,1,...,n-1]`,请构建一个数组`B[0,1,...,n-1]`,其中`B`中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法

### 解答

可以将`B[i]`的乘积分为两部分，左边为`A[0]*A[1]*...*A[i-1]`，右边为`A[i+1]，A[i+2]...A[n-1]`

先按自上而下为每个B[i]获得左边部分的乘积，然后自下而上获得右边部分的乘积

```c++
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> B;
        if(A.size() < 2)
            return B;
        
        int value = 1;
        B.push_back(1);
        for(int i = 1;i < A.size();i++){
            B.push_back(B.back() * A[i - 1]);
        }
        
        int tp = 1;
        for(int j = A.size() - 2;j >= 0;j--){
            tp = tp * A[j+1];
            B[j] *= tp;
        }
        
        return B;
    }
};
```

<br>
<br>

## 正则表达式匹配

[OJ链接](#https://leetcode.com/problems/regular-expression-matching/description/)

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
```

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

示例 3:

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

示例 4:

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

示例 5:

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 解答

**动态规划**

创建一个二维矩阵记录状态。`state[i][j]`表示`s[0~i-1]`能否和`p[0~j-1]`匹配：

* 如果`p[j - 1] == '*'`，此时`p[j - 2]`可以使用也可以不使用
    - 如果使用，`state[i][j] = ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j])`
    - 如果不使用，`state[i][j] = state[i][j - 2]`
* 如果`p[j - 1] == '.'`，此时`state[i][j] = state[i - 1][j - 1]`
* 否则，`state[i][j] = p[j - 1] == s[i - 1] && state[i - 1][j - 1]`

**注意二维bool矩阵的创建方法，这里不要使用vector**

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        bool **state = new bool*[len1 + 1];
        for(int i = 0;i <= len1;i++)
            state[i] = new bool[len2 + 1];
        
        //第一列，p = ""
        state[0][0] = true;
        for(int i = 1;i <= len1;i++)    state[i][0] = false;
        
        //第一行，s = ""
        state[0][1] = false;
        for(int j = 2;j <= len2;j++)    state[0][j] = (p[j - 1] == '*') ? (state[0][j - 2]) : false;
        
        for(int i = 1;i <= len1;i++)
            for(int j = 1;j <= len2;j++){
                if(p[j - 1] == '*')
                    state[i][j] = state[i][j - 2] || ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j]);
                else if(p[j - 1] == '.')
                    state[i][j] = state[i - 1][j - 1];
                else
                    state[i][j] = (p[j - 1] == s[i - 1]) && state[i - 1][j - 1];
            }
        
        return state[len1][len2];
    }
};
```

<br>
<br>

## 通配符匹配

[OJ链接](#https://leetcode.com/problems/wildcard-matching/description/)

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

示例 3:

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

示例 4:

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

示例 5:

```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

### 解答

使用动态规划

给出字符串s，和字符串模板p。假设matches\[0\]\[0\]表示s和p是否能匹配。可以根据p[0]进行分析：

* 如果p[0]==‘\*’，那么可以选择\*匹配一个字符，或者不匹配。如果匹配一个字符，那么matches\[0\]\[0\]取决于s.substr[1]与p是否匹配；如果\*不匹配一个字符，那么matches\[0\]\[0\]取决于s与p.substr[1]是否匹配。即matches\[0\]\[0\] = matches\[1\]\[0\] || matches\[0\]\[1\]
* 如果p[0]=='?'，那么必须匹配一个字符，因此matches\[0\]\[0\] = matches\[1\]\[1\]
* 否则，matches\[0\]\[0\] = s\[0\] == p\[0\] && matches\[1\]\[1\]

因此可以根据上面3种情况得到状态转移方程

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        vector<vector<char>> matches(len1 + 1,vector<char>(len2 + 1));
        for(int i = 0;i < len1;i++)  // p == ""
            matches[i][len2] = 0;
        matches[len1][len2] = 1;       // p == "" && s == ""
        for(int j = len2 - 1;j >= 0;j--) // s == ""
            matches[len1][j] = (p[j] == '*' && matches[len1][j + 1]);
        
        for(int i = len1 - 1;i >= 0;i--){ // s.substr[i] match p.substr[j] ?
            for(int j = len2 - 1;j >= 0;j--){
                if(p[j] == '?')
                    matches[i][j] = matches[i + 1][j + 1];
                else if(p[j] == '*')
                    matches[i][j] = matches[i + 1][j] || matches[i][j + 1];
                else
                    matches[i][j] = (s[i] == p[j] && matches[i + 1][j + 1]);
            }
        }
        
        return matches[0][0];
    }
};
```

<br>
<br>

## 两个字符串的最长公共子序列

[OJ链接](https://www.lintcode.com/problem/longest-common-subsequence/description)

给出2个字符串，找出它们的最长公共子序列（LCS）。返回其长度

例子：

* For `"ABCD"` and `"EDCA"`, the LCS is `"A"` (or `"D"`, `"C"`), return `1`.
* For `"ABCD"` and `"EACB"`, the LCS is `"AC"`, return `2`.

### 解答

假设两个字符串序列为X和Y，从结尾字符进行分析（设`n`和`m`为两个字符串的长度）：

* 如果结尾字符相等，那么问题转换为求序列`X(n-1)`和`Y(m-1)`的最长公共子序列，即：`LCS(X(n-1),Y(m-1)) + 1`
* 如果结尾字符不相等，那么问题转换成求`max(LCS(X(n-1),Y(m)),LCS(X(n),Y(m-1)))`

为了防止求重复子问题，可以使用二维矩阵state保存状态（即每个LCS），从左上角往右下角进行求解

复杂度：

* **时间复杂度**：`O(n * m)`
* **空间复杂度**：
    - 无状态压缩：`O(n * m)`
    - 状态压缩：`O(n)`或`O(m)`

> 也可以从起始字符进行分析

#### 1）无状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[0][0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int i = 1;i < len1;i++) //第一列
            state[i][0] = A[i] == B[0] ? 1 : state[i - 1][0];
        for(int j = 1;j < len2;j++) //第一行
            state[0][j] = A[0] == B[j] ? 1 : state[0][j - 1];
        for(int i = 1;i < len1;i++)
            for(int j = 1;j < len2;j++)
                state[i][j] = A[i] == B[j] ? 1 + state[i - 1][j - 1] : max(state[i - 1][j],state[i][j - 1]);
                
        return state[len1 - 1][len2 - 1];
    }
};
```

#### 2）状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<int> state(len2,0);
        state[0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int j = 1;j < len2;j++) //第一行
            state[j] = A[0] == B[j] ? 1 : state[j - 1];
        for(int i = 1;i < len1;i++){
            int tmp = state[0],tmp2;
            state[0] = A[i] == B[0] ? 1 : state[0];
            for(int j = 1;j < len2;j++){
                tmp2 = state[j];
                state[j] = A[i] == B[j] ? 1 + tmp : max(state[j],state[j - 1]);
                tmp = tmp2;
            }
        }        
        return state[len2 - 1];
    }
};
```

<br>
<br>

## 两个字符串的最长公共子串

[OJ链接](https://www.lintcode.com/problem/longest-common-substring/description)

给出2个字符串，找出它们的最长公共子串，返回其长度

例子：

* Given A = `"ABCD"`, B = `"CBCE"`, return 2

> 子串和子序列的不同在于：子串连续，子序列可以不连续

### 解答

对于字符串序列`X`和`Y`，设`state[i,j]`表示以`X[i]`和`Y[j]`开头的最长公共子串。从`X`和`Y`的起始字符分析：

* 如果起始字符相同，那么`state[0,0] = 1 + state[1,1]`
* 如果起始字符不同，那么`state[0,0] = 0`

因此，创建一个二维矩阵，可以求出所有`state[i][j]`的值，最长公共子串就是其中最大的一个

* 时间复杂度：`O(n * m)`
* 空间复杂度：`O(n * m)`

> 也可以从结尾字符开始分析；最终结果取决于每一个`state[i][j]`，所以这里不能用状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: the length of the longest common substring.
     */
    int longestCommonSubstring(string &A, string &B) {
        // write your code here
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[len1 - 1][len2 - 1] = A[len1 - 1] == B[len2 - 1] ? 1 : 0;
        //DP
        for(int i = len1 - 2;i >=0;i--) //最后一列
            state[i][len2 - 1] = A[i] == B[len2 - 1] ? 1 : 0;
        for(int j = len2 - 2;j >=0;j--) //最后一行
            state[len1 - 1][j] = A[len1 - 1] == B[j] ? 1 : 0;
        for(int i = len1 - 2;i >= 0;i--)
            for(int j = len2 - 2;j >= 0;j--)
                state[i][j] = A[i] == B[j] ? 1 + state[i + 1][j + 1] : 0;
                
        int max = 0;
        for(auto row : state)
            for(int len : row)
                if(len > max)
                    max = len;
        
        return max;
    }
};
```

## 判断字符串是否表示一个数值

[OJ链接](https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串`"+100"`,`"5e2"`,`"-123"`,`"3.1416"`和`"-1E-16"`都表示数值。 但是`"12e"`,`"1a3.14"`,`"1.2.3"`,`"+-5"`和`"12e+4.3"`都不是

### 解答

```c++
class Solution {
public:
    bool isNumeric(char* string)
    {
        if(!string)
            return false;
        
        const char *curr = string;
        bool findE = false,findPoint = false;
        int positionOfE;
        while(*curr != '\0'){
            if(*curr == '+' || *curr == '-'){
                if(curr == string || (findE && (curr - string) == (positionOfE + 1) && *(curr + 1) != '\0')){
                    curr++;
                    continue;
                }
                return false;
            }
            else if(*curr == 'E' || *curr == 'e'){
                //只能在中间
                if(!findE && curr != string && *(curr + 1) != '\0'){
                    findE = true;
                    positionOfE = curr - string;
                    curr++;
                    continue;
                }
                return false;
            }
            else if(*curr == '.'){
                if(findE || findPoint)
                    return false;
                findPoint = true;
            }
            else if(*curr < '0' || *curr > '9'){
                return false;
            }
            curr++;
        }
        
        return true;
    }

};
```

<br>
<br>

## 把字符串转换成整数

OJ链接：[牛客网](https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)、[Leetcode](https://leetcode.com/problems/string-to-integer-atoi/description/)

实现 `atoi`，将字符串转为整数。

在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。

当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。

若函数不能执行有效的转换，返回 0。

说明：

假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2
^31 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。

示例 1:

```
输入: "42"
输出: 42
```

示例 2:

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

示例 3:

```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

示例 4:

```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

示例 5:

```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−2^31) 。
```

### 解答

* 使用long long保存中间结果，可以判断是否溢出
* ”4 2“输出为4，不为42，即数字中间的空格不能忽略
* "+"输出为0

```c++
class Solution {
public:
    int myAtoi(string str) {
        int i = 0;
        //找到第一个不为' '的位置
        for(;i < str.length() && str[i] == ' ';i++) ;
        if(i >= str.length())   return 0;
        
        bool negative = (str[i] == '-');
        if(str[i] == '+' || str[i] == '-') i++;
        
        long long res = 0;
        for(;i < str.length();i++){
            if(str[i] > '9' || str[i] < '0')    break;
            res = res * 10 + (str[i] - '0');
            if(res > INT_MAX){
                if(!negative)   return INT_MAX;
                if(res - 1 > INT_MAX)   return INT_MIN;
            }
        }
        
        if(negative)    res *= -1;
        return (int)res;
    }
};
```

<br>
<br>

## 字符串中第一个只出现一次的字符

[OJ链接](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个字符串(1<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置

### 解答

#### 1）暴力法

从头遍历每个字符，对于任意字符，遍历剩余字符看是否重复出现

* 时间复杂度：O(n^2)
* 空间复杂度：O(1)

#### 2）哈希表

用一个辅助数组，下标为字符，值为字符出现次数，第一次遍历时统计每个字符的出现次数，第二次遍历找到第一个只出现一次的字符

* 时间复杂度：O(n)
* 空间复杂度：O(1)（如果都是ASCII字符，只需要256大小的数组）

```c++
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        int positions[256];
        
        for(int i = 0;i < 256;i++){
            positions[i] = -1;
        }
        
        int sz = str.size();
        for(int i = 0;i < sz;i++){
            if(positions[str[i]] == -1)
                positions[str[i]] = i;
            else
                positions[str[i]] = -2;
        }
        
        int minidx = sz - 1;
        for(int j = 0;j < 256;j++)
            if(positions[j] >= 0 && positions[j] < minidx)
                minidx = positions[j];
        return minidx;
    }
};
```

<br>
<br>

## 字符流中第一个只出现一次的字符

[OJ链接](https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

请实现一个函数用来找出字符流中第一个只出现一次的字符

例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"

### 解答

> 和 [字符串中第一个只出现一次的字符](#字符串中第一个只出现一次的字符) 的不同的是：字符流只能读取一次，因此无法统计每个字符的出现次数，然后从头遍历，找到第一个只出现1次的字符

使用一个辅助数组，但是辅助数组记录字符首次出现的下标（初始化为-1，多次出现的字符下标为-2），每次遍历数组，查找下标最小的字符，就是结果

```c++
class Solution
{
public:
  //Insert one char from stringstream
    void Insert(char ch)
    {
         if(positions[ch] == -1)
            positions[ch] = index;
         else
             positions[ch] = -2;
        index++;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
        int minidx = index;
        char ch;
        for(int j = 0;j < 256;j++)
            if(positions[j] >= 0 && positions[j] < minidx){
                minidx = positions[j];
                ch = j;
            }
        if (minidx == index)
            ch = '#';
        return ch;
    }
    Solution(){
        index = 0;
        for(int i = 0;i < 256;i++)
            positions[i] = -1;
    }
private:
    int index;
    int positions[256];
};
```

<br>
<br>

## 翻转单词顺序

OJ链接：[牛客网](https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)、[Leetcode](https://leetcode.com/problems/reverse-words-in-a-string/description/)

给定一个字符串，逐个翻转字符串中的每个单词

示例:  

```
输入: "the sky is blue",
输出: "blue is sky the".
```

说明:

* 无空格字符构成一个单词。
* 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括（**牛客不含这个条件**）
* 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个（**牛客不含这个条件**）

进阶: 请选用C语言的用户尝试使用 O(1) 时间复杂度的原地解法

### 解答

> 以下是牛客网的解答

两次翻转字符串（先翻转所有，再翻转每个单词或先翻转每个单词，再翻转所有）

```c++
class Solution {
public:
    string ReverseSentence(string str) {
        if(str.size() < 2)
            return str;
         
        int sz = str.size();
        Reverse(str,0,sz - 1);
         
        int firstCharIdx = 0;
        for(int i = 0;i < sz;i++){
            if(str[i] == ' '){
                if(str[firstCharIdx] == ' ')
                    firstCharIdx++;
                else{
                    Reverse(str,firstCharIdx,i - 1);
                    firstCharIdx = i + 1;
                }
            }
        }
         
        if(str[sz - 1] != ' ')
            Reverse(str,firstCharIdx,sz - 1);
         
        return str;
    }
     
    void Reverse(string &str,int l,int r){
        if(l < 0 || r >= str.size())
            return;
         
        while(l < r){
            char c = str[r];
            str[r] = str[l];
            str[l] = c;
            l++;
            r--;
        }
    }
};
```

<br>
<br>

## 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能

比如，输入字符串`“abcdefg”`和数字`2`，函数返回左旋转两位得到的结果`“cdefgab”`

### 解答

先对前半部和后半部的字符串做翻转，然后对整个字符串做翻转；比如上面的例子，对前半部和后半部翻转后得到`“bagfedc”`，然后翻转整个字符串，得到`"cdefgab"`

<br>
<br>

## 字符串的排列

[OJ链接](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba

输入描述：

输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母

### 解答

* 把第一个字符和后面所有的字符交换，然后固定第一个字符，求后面字符的全排列
* 交换时，使用一个哈希表，统计这个字符以前是否处理过，处理过则直接跳过

```c++
class Solution {
public:
    vector<string> Permutation(string str) {
        vector<string> res;
        if(str.size() == 0)
            return res;
        
        Permutation(str,0,res);
        //为了按字典序输出，需要排序
        sort(res.begin(),res.end());
        return res;
    }
    
    void Permutation(string &s,int idx,vector<string> &res){
        int sz = s.size();
        if(idx == (sz - 1)){
            res.push_back(s);
            return;
        }
        
        set<char> swaped;//为了处理相同的字符
        for(int i = idx;i < sz;i++){
            char c = s[i];
            //说明遇到了相同的字符
            if(swaped.find(c) != swaped.end()){
                continue;
            }
            swaped.insert(c);
            s[i] = s[idx];
            s[idx] = c;
            
            Permutation(s,idx+1,res);
            
            s[idx] = s[i];
            s[i] = c;
        }
    }
};
```

<br>
<br>

## 求字符的所有组合

求字符的所有组合（相同字符的不同排列是同一组合），“abc”的组合有"a","b","c","ab","ac","bc","abc"

### 解答

在求n个字符的长度为m的组合时，把这n个字符分成两部分：第一个字符和其余所有字符。如果组合里包含第一个字符，则下一步在剩余字符里面选取m-1个字符；如果组合里不包含第一个字符，则下一步在剩余的n-1个字符里选取m个字符

<br>
<br>

## 替换空格

[OJ链接](https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数，将一个字符串中的空格替换成`“%20”`。例如，当字符串为`We Are Happy`.则经过替换之后的字符串为`We%20Are%20Happy`

### 解答

直接在原串上修改，假设后面有足够多的空余内存

先计算好替换后的长度，然后从后向前替换

```c++
class Solution {
public:
    //参数length表示str开始的可用内存空间
    void replaceSpace(char *str,int length) {
        if(length <= 0)
            return ;
        
        int length1 = 0,blankNumber = 0,i = 0;
        while(str[i] != '\0'){
            if(str[i] == ' ')
                blankNumber++;
            length1++;
            i++;
        }
            
        int length2 = length1 + 2 * blankNumber;
        if(length2 >= length)
            return;
        
        int curr = length2 - 1;
        for(int i = length1 - 1;i >= 0;i--){
            if(str[i] == ' '){
                str[curr--] = '0';
                str[curr--] = '2';
                str[curr--] = '%';
            }
            else
                str[curr--] = str[i];
        }
        str[length2] = '\0';
    }
};
```

<br>
<br>

## 从尾到头打印链表

[OJ链接](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一个链表，从尾到头打印链表每个节点的值

### 解答

1. 反序，再打印（但会修改链表）
2. 使用一个栈（鲁棒性好）
3. 递归（递归本质上就是一个栈结构，链表过长时可能栈溢出）

> 以下为方法3的代码

```c++
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        if(!head)
            return vector<int>();
        
        vector<int> res;
        printListFromTailToHead(head,res);
        
        return res;
    }
    
    void printListFromTailToHead(ListNode* head,vector<int> &res){
        if(!head)
            return;
        
        printListFromTailToHead(head->next,res);
        res.push_back(head->val);
    }
};
```

<br>
<br>

## 链表中倒数第k个节点

[OJ链接](https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个链表，输出该链表中倒数第k个结点

### 解答

使用2个指针，指向链表头节点。第一个指针先走k（或k-1）步，然后两个指针一起走，当前面走的指针到为NULL时（或前面走的指针指向节点的下一节点为NULL时），后面走的指针指向的节点就是倒数第k个节点

注意k比链表节点总数大以及k为0的情况

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(k == 0 || !pListHead)//unsigned int肯定大于等于0
            return nullptr;
        
        int first = k - 1;
        ListNode *p1 = pListHead,*p2 = pListHead;
        while(p1->next && first){
            p1 = p1 -> next;
            first--;
        }
        
        if(first > 0)
            return nullptr;
        
        while(p1->next){
            p1 = p1->next;
            p2 = p2->next;
        }
        
        return p2;
    }
};
```

<br>
<br>

## 链表的中间节点

求链表的中间节点。如果节点总数为偶数，则返回中间节点的任意一个

### 解答

使用两个指针，每次其中一个指针走一步，另外一个指针走两步

> 举一反三：当用一个指针遍历链表不能解决问题时，可以尝试用两个指针来遍历。可以让其中一个指针遍历的速度快一些，或者让它先在链表上走若干步

<br>
<br>

## 链表中环的入口节点

[OJ链接](https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

一个链表中包含环，请找出该链表的环的入口结点

### 解答

* 使用两个指针，一个1步，一个2步，在环中相遇，记录相遇节点，再遍历到此节点，计算出环长；
* 然后再用2个指针，一个先走环长步，然后两个一起走，会在入口节点相遇；

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* EntryNodeOfLoop(ListNode* pHead)
    {
        if(!pHead)
            return nullptr;

        ListNode *p1 = pHead,*p2 = pHead;
        while(true){
            p1 = p1->next;
            p2 = p2->next;
            if(p2)    {p2 = p2->next;}
            if(!p2)    return nullptr;//由于p2走得快，如果链表无环，肯定会在这里返回

            if(p1 == p2)    break;
        }

        int circleLength = 1;
        p2 = p2->next;
        while(p2 != p1)    {circleLength++;p2 = p2->next;}

        p1 = pHead,p2 = pHead;
        while(circleLength){
            p2 = p2->next;
            circleLength--;
        }
        while(p1 != p2){
            p1 = p1->next;
            p2 = p2->next;
        }

        return p1;
    }
};
```

<br>
<br>

## 删除链表中的节点

[OJ链接](https://leetcode.com/problems/delete-node-in-a-linked-list/description/)

请编写一个函数，使其可以删除某个链表中给定的（**非末尾**）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

    4 -> 5 -> 1 -> 9

示例 1:

```
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

示例 2:

```
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

说明:

* 链表至少包含两个节点。
* 链表中所有节点的值都是唯一的。
* 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
* 不要从你的函数中返回任何结果。

### 解答

> 如果传入尾节点，因为传入的参数为指针（而非指针的指针），所以没有办法实现删除

将下一个节点的值复制过来，然后删除下一个节点：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode *tp = node->next;
        node->val = tp->val;
        node->next = tp->next;
        delete tp;
    }
};
```

<br>
<br>

## 删除有序链表中的冗余节点

[OJ链接](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

```
输入: 1->1->2
输出: 1->2
```

示例 2:

```
输入: 1->1->2->3->3
输出: 1->2->3
```

### 解答

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode **curr = &head,*tp;

        while(*curr){//当前节点不为NULL
            if((*curr)->next && (*curr)->val == (*curr)->next->val){
                tp = (*curr)->next;
                (*curr)->next = tp->next;
                tp->next = NULL;
            }
            else
                curr = &((*curr)->next);
        }
        
        return head;
    }
};
```

## 删除有序链表中重复的节点

[OJ链接](https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针

例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

### 解答

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(!pHead)
            return nullptr;
        
        ListNode *p = pHead,*tp,*prev = nullptr;
        while(p && p->next){//遍历到倒数第二个节点
            if(!(p->next) || p->next->val != p->val){//如果没有下一个节点或者下一个节点与当前遍历的节点的值不等
                prev = p;
                p = p->next;
                continue;
            }
            
            while(p->next && p->val == p->next->val){//对于每个节点，只要还有下一个节点，并且下一个节点相同，则删除下一节点
                tp = p->next;
                p->next = p->next->next;
                tp->next = nullptr;
                delete tp; 
            }
            
            //到此，说明当前遍历的节点存在重复，并且已经删除了其后的所有重复，需要再删除当前节点
            if(!prev){//说明链表的头结点就存在重复，需要删除头结点
                pHead = p->next;
                p->next = nullptr;
                delete p;
                p = pHead;
            }
            else{
                prev->next = p->next;
                p->next = nullptr;
                delete p;
                p = prev->next;
            }
        }
        
        return pHead;
    }
};
```

<br>
<br>

## 反转链表

[OJ链接](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个链表，反转链表后，输出新链表的表头

### 解答

#### 1）迭代

每次循环将curr.next修改为前一节点

因为需要将当前节点的next节点修改为前一节点，所以需要用一个指针prev记录前一节点。同时，由于修改了当前节点的next节点后，无法访问原来的next节点，因此需要一个指针next，在修改前记录原来的next节点

* 时间复杂度：O(n)
* 空间复杂度：O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *curr = head,*next = head ? head->next : NULL,*prev = NULL;
        while(curr){
            curr->next = prev;
            prev = curr;
            curr = next;
            if(next)
                next = next->next;
        }
        
        return prev;
    }
};
```

#### 2）递归

```
n(1) -> n(2) -> ... -> n(k) -> n(k+1) <- ... <- n(m)
```

在m个节点的链表中，对于每次递归处理的节点k，假设节点k之后的节点已经处理完（逆序）。对于节点k，只需修改其next成员，以及节点(k+1)的next成员

```
n(k)->next->next = n(k);
n(k)->next = NULL;
```

函数返回逆序后链表的头结点，因此对于n(m)，直接返回n(m)

* 时间复杂度：O(n)
* 空间复杂度：O(n)（每次递归函数栈帧都会创建1个局部指针保存逆序后的链表头结点）

>注：不能假设对于每次递归处理的节点k，前k-1个节点已经逆序。因为节点k无法访问到前一节点，因此无法将k节点逆序，因此对于节点k+1，前k个节点无法逆序。也不能假设前k个节点已经逆序，因为如果前k个节点已经逆序，对于节点k，将k+1节点逆序，当处理k+1节点时，无法访问到k+2节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL || head->next == NULL) return head;
        
        ListNode* p = reverseList(head->next);
        
        head->next->next = head;
        head->next = NULL;
        
        return p;
    }
};
```

<br>
<br>

## 复杂链表的复制

[OJ链接](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

### 解答

#### 1）方法一

* 复制原始链表上的每个节点，用m_pNext链接起来
* 设置复制链表每个节点的random成员

```c++
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* pHead)
    {
        if(!pHead)
            return nullptr;
        
        map<RandomListNode*,RandomListNode*> relationRMap,relationMap;
        
        RandomListNode* p = pHead;
        RandomListNode *node = new RandomListNode(p->label);
        relationRMap[p] = node;
        relationMap[node] = p;
        RandomListNode *head = node;
        
        while(p->next){
            RandomListNode *nextnode = new RandomListNode(p->next->label);
            node->next = nextnode;
            node = nextnode;
            
            relationRMap[p->next] = nextnode;
            relationMap[nextnode] = p->next;
            
            p = p->next;
        }
        
        p = head;
        while(p){
            if(relationMap.find(p)->second->random)
                p->random = relationRMap.find(relationMap.find(p)->second->random)->second;
            p = p->next;
        }
        
        return head;
    }
};
```

#### 2）方法二

第一轮复制节点，使新节点链接在旧链表对应节点的后面：

```
        -------      -------      -------      -------
... -> | 旧nd i | ->| 新nd i | ->|旧nd i+1| -> |新nd i+1| -> ... 
        -------      -------      -------      -------
```

第二轮遍历复制random，新节点的random指向对应旧节点random指向节点对应的新节点，因为现在对应的新节点在旧节点之后，所以新节点的random指向对应纠结点random指向节点的下一节点

第三轮遍历将新链表的节点和旧链表的节点拆开，成为2个链表（这一步不能与第二轮遍历合并，因为后面的节点的random可能指向前面的节点，如果在设置random成员的同时拆链表，由于前面的节点已经拆开，所以新链表节点的random成员会指向旧链表的节点）

```c++
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head)   return NULL;
        
        RandomListNode *p = head;
        while(p){
            RandomListNode *nd = new RandomListNode(p->label);
            nd->next = p->next;
            p->next = nd;
            p = nd->next;
        }
        
        //这一轮循环不能拆链表，因为后面的节点的random可能指向前面的节点，
        //如果在设置random成员的同时拆链表，由于前面的节点已经拆开，所以新链表
        //节点的random成员会指向旧链表的节点
        p = head;
        while(p){
            if(p->random)
                p->next->random = p->random->next;
            p = p->next->next;
        }
        
        p = head;
        head = p->next; //更新head指向复制出的新链表的表头
        while(p){
            RandomListNode *tp = p->next;
            p->next = tp->next;
            p = p->next;
            if(p)
                tp->next = p->next;
        }
        
        return head;
    }
};
```

<br>
<br>

## 合并两个有序链表

[OJ链接](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则

### 解答

创建一个辅助节点作为链表头节点（栈上分配），使用2个指针head1和head2分别指向2个链表的头结点，使用1个指针cur指向已合并链表的尾节点，每次选择head1和head2中较小者链入cur结尾，然后更新相应指针，直到其中一个链表的所有节点已经合并完成，最后将另一个链表剩余的节点链入即可：

```c++
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
            val(x), next(NULL) {
    }
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        ListNode head(0);
        ListNode * cur = &head;
        while(pHead1 && pHead2){
            if(pHead1->val < pHead2->val){
                cur->next = pHead1;
                pHead1 = pHead1->next;
            }
            else{
                cur->next = pHead2;
                pHead2 = pHead2->next;
            }
            cur = cur->next;
        }
        
        if(pHead1)    cur->next = pHead1;
        if(pHead2)    cur->next = pHead2;
        
        return head.next;
    }
};
```
<br>
<br>

## 两个链表的第一个公共节点

[OJ链接](https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入两个链表，找出它们的第一个公共结点

### 解答

#### 1）哈希表

遍历其中一个链表，如A。将链表中的每一个节点的地址存入hash set，然后遍历链表B，找出B中的每一个节点是否在hash set中，如果存在，则第一个查找到的节点就是相交节点的开始节点

* 时间复杂度：O(m+n)
* 空间复杂度：O(n) or O(m)

#### 2）双指针

长链表先走长度之差步，然后同时遍历，找到第一个相同节点

* 时间复杂度：O(m+n)
* 空间复杂度：O(1)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int len1 = 0,len2 = 0;
        ListNode *p1 = headA,*p2 = headB;
        
        while(p1){
            len1++;
            p1 = p1->next;
        }
        while(p2){
            len2++;
            p2 = p2->next;
        }
        
        int diff = abs(len1 - len2);
        if(len1 > len2)
            while(diff--)
                headA = headA->next;
        else
            while(diff--)
                headB = headB->next;
        
        while(headA && headB){
            if(headA == headB)  return headA;
            headA = headA->next;
            headB = headB->next;
        }
        
        return NULL; //2个链表不相交
    }
};
```

<br>
<br>

## 重建二叉树

OJ链接：[牛客](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)、[Leetcode](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回

### 解答

前序遍历序列的第一个节点是根节点，可以根据根节点将中序遍历序列划分成左子树区间和右子树区间。根据左子树和右子树节点的个数，又可以将前序遍历序列划分成左子树区间和右子树区间。因此得到了左子树的前序遍历序列和中序遍历序列、右子树的前序遍历序列和中序遍历序列。递归构造左右子树

```c++
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty() || vin.empty() || (pre.size() != vin.size())){
            return nullptr;
        }
        
        int sz1 = pre.size();
        int sz2 = vin.size();
        
        return reConstructBinaryTreeCore(pre,vin,0,sz1-1,0,sz2-1);
    }
    
    TreeNode* reConstructBinaryTreeCore(const vector<int> &pre,const vector<int> &vin
                                   ,int preL,int preR,int vinL,int vinR)
    {
        if(preL > preR)
            return nullptr;
        
        TreeNode *root = new TreeNode(pre.at(preL));
        
        int i = vinL;
        for (;i <= vinR;i++)
            if(vin.at(i) == pre.at(preL))
                break;
        
        int leftsz = i - vinL;
        int rightsz = vinR - i;
        
        root->left = reConstructBinaryTreeCore(pre,vin,preL+1,preL+leftsz,vinL,i-1);
        root->right = reConstructBinaryTreeCore(pre,vin,preL+leftsz+1,preR,i+1,vinR);
        
        return root;
    }
};
```

<br>
<br>

## 中序遍历的下一个节点

[OJ链接](https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针

### 解答

* 如果一个节点有右子树，那么下一个节点就是它的右子树中的最左子节点
* 如果节点没有右子树，并且它是父节点的左子节点，则下一节点就是它的父节点
* 如果节点没有右子树，并且它是父节点的右子节点，则沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点。如果这样的节点存在，那么这个节点的父节点就是我们要找的下一个节点

```c++
/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next;
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/

class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(!pNode)
            return nullptr;
        
        if(pNode->right)
            return MostLeft(pNode->right);
        
        TreeLinkNode* nd = pNode;
        while(nd->next && nd->next->left != nd)
            nd = nd->next;
        if(!nd->next)
            return nullptr;
        else
            return nd->next;
    }
    
    TreeLinkNode* MostLeft(TreeLinkNode* nd){
        if(!nd)
            return nullptr;
        
        if(!nd->left)
            return nd;
        
        return MostLeft(nd->left);
    }
};
```

<br>
<br>

## 树的子结构

[OJ链接](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

### 解答

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(!pRoot1 || !pRoot2)
            return false;
        
        bool res = false;
        if(pRoot1->val == pRoot2->val)    res = SameTree(pRoot1->left,pRoot2->left) && SameTree(pRoot1->right,pRoot2->right);
        if(res)    return true;
        
        res = HasSubtree(pRoot1->left,pRoot2) || HasSubtree(pRoot1->right,pRoot2);
        return res;
    }
    
    bool SameTree(TreeNode* pRoot1,TreeNode* pRoot2)
    {
        if(!pRoot2)    return true;
        if(!pRoot1)    return false;
        
        if(pRoot1->val == pRoot2->val)    return SameTree(pRoot1->left,pRoot2->left) && SameTree(pRoot1->right,pRoot2->right);
        return false;
    }
};
```

<br>
<br>

## 序列化二叉树

[OJ链接](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/)

实现两个函数，分别用来序列化和反序列化二叉树

### 解答

#### 1）方法一

可以先把一棵二叉树序列化成一个前序遍历和一个中序遍历的序列，然后在反序列化时通过这两个序列重构出原二叉树

这种思路有两个缺点：

* 该方法要求二叉树中不能有数值重复的节点；
* 只有当两个序列中所有数据都读出后才能开始反序列化。如果两个遍历序列的数据是从一个流里读出来的，那么可能需要等待较长的时间

#### 2）方法二

如果二叉树序列化是从根节点开始的，那么相应的反序列化在根节点的数值读出来的时候就可以开始了。因此，可以根据前序遍历的顺序来序列化二叉树，因为前序遍历是从根节点开始的。在遍历二叉树碰到nullptr指针时，这些nullptr指针序列化为一个特殊的字符（如'#'）

对于如下二叉树，被序列化成字符串“1,2,4,#,#,#,3,5,#,#,6,#,#”

```
      1
     / \
    2   3
   /   / \
  4   5   6
```

反序列化时，第一个读出的数字是1。由于前序遍历是从根节点开始的，这是根节点的值。接下来读出的数字是2，根据前序遍历的规则，这是根节点的左子节点的值。同样，接下来的数字4是值为2的节点的左子节点。接着从序列化字符串里读出两个字符'#'，这表明值为4的节点的左、右子节点均为nullptr指针，因此它是一个叶节点。接下来回到值为2的节点，重建它的右子节点。由于下一个字符是'#'，这表明值为2的节点的右子节点为nullptr指针。这个节点的左、右子树都已经构建完毕，接下来回到根节点，反序列化根节点的右子树

下一个序列化字符串中的数字是3，因此右子树的根节点的值为3。它的左子节点是一个值为5的叶节点，因为接下来的三个字符是“5,#,#”。同样，它的右子节点是值为6的叶节点，因为最后3个字符是“6,#,#”

总结前面的过程，我们都是把二叉树分解成3部分：根节点、左子树和右子树。在处理（序列化或反序列化）它的根节点之后再分别处理它的左、右子树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (root == nullptr) return "#";
        return to_string(root->val)+","+serialize(root->left)+","+serialize(root->right);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        return deserializeCore(data);
    }
    
private:
    TreeNode* deserializeCore(string &data){
        if(data == "")    return NULL;
        
        if(data[0] == '#'){
            data = data.substr(data.find(',') + 1);
            return NULL;
        }
        
        size_t idx;
        int val = stoi(data,&idx);
        data = data.substr(idx + 1);
        
        TreeNode *node = new TreeNode(val);
        
        node->left = deserializeCore(data);
        node->right = deserializeCore(data);
        
        return node;
    }
};
```

<br>
<br>

## 判断一棵二叉树是否是BST

[OJ链接](https://leetcode.com/problems/validate-binary-search-tree/description/)

给定一个二叉树，判断其是否是一个有效的二叉搜索树

### 解答

#### 1）错误的解法

对于节点node，如果

1. node-val > node->left->val;
2. node->val < node->right->val;

那么继续判断左右子树是否满足该性质，如果满足，那么该树就是一棵BST

但是这种方法只满足局部BST性质，举例来说：

```
       2
      / \
     1   5
    / \ / \
   0  3 4  6 
```

这个例子满足上面的性质：

* 对于节点2，其左子节点小于2，右子节点大于2
* 节点1的左子节点小于1，右子节点大于1
* 5的左子节点小于5，右子节点大于6

如果按照上面的逻辑，会判断这棵树是BST，但是在根节点2的左子树中，存在节点3，大于根节点2，所以实际上并不是一棵BST

#### 2）正确的解法

中序遍历，如果是BST，那么中序遍历序列一定是递增的序列，只需要用一个变量维护已经遍历过的序列的最后一个值prev，通过比较当前节点的值和prev，如果依然满足递增的性质，那么继续判断，否则返回false

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        int *prev = nullptr;
        return isValidBST(root,&prev);
    }
    
    bool isValidBST(TreeNode* node,int **pprev){
        if(!node)
            return true;
        
        bool res = isValidBST(node->left,pprev);
        
        if(*pprev)
            res = res && (node->val > **pprev);
        *pprev = &(node->val);
        
        res = res && isValidBST(node->right,pprev);
        
        return res;
    }
};
```

<br>
<br>

## BST的后序遍历序列

[OJ链接](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同

> 扩展：判断数组是不是某BST的前序遍历结果

### 解答

左->右->根  ---> 小->大->中

首先判断序列是否满足这种大小关系，然后递归处理子树

```c++
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        int sz = sequence.size();
        
        if(sz == 0)
            return false;
        
        return VerifySquenceOfBST(sequence,0,sz-1);
    }
    
    bool VerifySquenceOfBST(const vector<int> &sequence,int l,int r){
        if(l >= r)
            return true;
        
        int m,tp = l;
        int root = sequence.at(r);
        while(tp < r && sequence.at(tp++) < root){}
        if(tp < r){
            tp = tp - 1;
            m = tp;
            while(tp < r){
                if(sequence.at(tp) < root){
                    return false;
                }
                tp++;
            }
        }
        
        return VerifySquenceOfBST(sequence,l,m-1) && VerifySquenceOfBST(sequence,m,r-1);
        
    }
};
```

<br>
<br>

## BST转双链表

[OJ链接](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向

### 解答

中序遍历，​​当前节点之前的节点已经处理好，使用一个变量保存链表的最后一个节点，对当前节点，处理它和链表最后一个节点的指向关系，并更新链表的最后一个节点。

使用指针的指针记录链表的最后一个节点，如果使用指针，函数调用修改的是形参last指针，调用返回后实参last并未修改

```c++
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        TreeNode *last = nullptr;
        
        ConvertCore(pRootOfTree,&last);
        
        while(last && last->left){
            last = last->left;
        }
        
        return last;
    }
    
    void ConvertCore(TreeNode* pRootOfTree,TreeNode **last)
    {
        if(!pRootOfTree)
            return;
        
        ConvertCore(pRootOfTree->left,last);
        pRootOfTree->left = *last;
        if(*last)
            (*last)->right = pRootOfTree;
        *last = pRootOfTree;
        ConvertCore(pRootOfTree->right,last);
    }
};
```

<br>
<br>

## 单链表转BST

[OJ链接](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/)

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

```
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

### 解答

首先变量链表统计节点总数n

假设二叉搜索树的构造函数为f(n)，即构造n个节点的二叉搜索树。为了平衡，左右子树的节点应该对半分。假设为左子树分配n/2个节点，由于根节点占用了1个节点，那么需要为右子树分配n-n/2-1个节点。因此有：

```
root->left = f(n/2);
root->right = f(n-n/2-1);
```

那么root->val应该等于什么？注意上面的赋值顺序，这显然是一个递归调用的过程，在最深层会构造整棵二叉搜索树的最左子树（即最左子节点）。由于BST的性质，这个节点显然是最小值，因此应该使用链表头节点。所以左边最深处使用到第一个链表节点，那么遍历顺序就应该是中序遍历，因此root->val的设置应该在上面2个语句之间。同时，构造完一个节点后，链表也要前进一个节点：

```c++
//在对root->val赋值之前，需要为left成员赋值，因此初始化val为0
TreeNode *root = new TreeNode(0);
root->left = f(n/2);
root->val = curr->val //curr为当前链表节点
curr = curr->next;
root->right = f(n-n/2-1);
```

代码：

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        ListNode* p = head;
        int count = 0;
        while(p) {
            count++;
            p = p->next;
        }
        
        return sortedListToBSTCore(count,&head);
    }
private:
    TreeNode* sortedListToBSTCore(int count,ListNode** curr){
        if(count <= 0)  return NULL;
        
        TreeNode *root = new TreeNode(0);
        root->left = sortedListToBSTCore(count / 2,curr);
        root->val = (*curr)->val;
        (*curr) = (*curr)->next;
        root->right = sortedListToBSTCore(count - count / 2 - 1,curr);
        
        return root;
    }
};
```

<br>
<br>

## BST第k小的节点

OJ链接：[牛客](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=4&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)、[Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/)

给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 k 个最小的元素。

说明：

你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
```

示例 2:

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
```

进阶：

如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 `kthSmallest` 函数？

### 解答

#### 1）递归

```c++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(!root || k < 0)   return -1;
        
        int res;
        preOrderTraversal(root,k,res);
        
        return res;
    }
private:
    void preOrderTraversal(TreeNode *node,int &k,int &res){
        if(!node)   return;
        
        preOrderTraversal(node->left,k,res);
        if(k == 0)  return;
        if(--k == 0)  res = node->val;
        else    preOrderTraversal(node->right,k,res);
    }
};
```

#### 2）迭代

```c++
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(!root || k < 0)  return -1;
        
        stack<TreeNode*> s;
        TreeNode *curr = root;
        while(curr || !s.empty()){
            if(curr){
                s.push(curr);
                curr = curr->left;
            }
            else{
                TreeNode *nd = s.top();
                if(k == 1)  return nd->val;
                s.pop();k--;
                curr = nd->right;
            }
        }
        
        return -1;//k大于BST的节点总数
    }
};
```

<br>
<br>

## 按层不分行输出二叉树

[OJ链接](https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

从上往下打印出二叉树的每个节点，同层节点从左至右打印

### 解答

使用队列进行BFS，将根节点插入队列，当队列不为空时，弹出一个节点，打印，然后将该节点的左右子节点插入队列

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> res;
        if(!root)
            return res;
        
        deque<TreeNode*> q;
        q.push_back(root);
        
        TreeNode *curr;
        while(!q.empty()){
            curr = q.front();
            res.push_back(curr->val);
            q.pop_front();
            
            if(curr->left)
                q.push_back(curr->left);
            if(curr->right)
                q.push_back(curr->right);
        }
        
        return res;
    }
};
```

<br>
<br>

## 按层分行输出二叉树

[OJ链接](https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行

### 解答

使用队列进行BFS。除此之外，为了实现分行打印，使用2个变量：一个表示当前层中还没打印的节点数，另一个变量表示下一层节点的数目。当前层还未打印的节点数为0时，打印换行符，然后将下一层节点的数目赋值给当前层还未打印的节点数，然后将下一层节点的数目设置为0，开始打印下一层。一直到队列为空

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int> > res;
            if(!pRoot)
                return res;
            
            deque<TreeNode*> dq;
            dq.push_back(pRoot);
            
            vector<int> linevec;
            int currleft = 1,nextlinecount = 0;
            TreeNode* curr;
            while(currleft != 0){
                curr = dq.front();
                dq.pop_front();
                currleft--;
                linevec.push_back(curr->val);
                
                if(curr->left){
                    dq.push_back(curr->left);
                    nextlinecount++;
                }
                if(curr->right){
                    dq.push_back(curr->right);
                    nextlinecount++;
                }
                
                if(currleft == 0){
                    res.push_back(linevec);
                    linevec.clear();
                    currleft = nextlinecount;
                    nextlinecount = 0;
                }
            }
            return res;
        }
};
```

<br>
<br>

## 之字形打印二叉树

[OJ链接](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=3&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推

### 解答

* 需要两个栈，在遍历某个栈打印某一层的节点时，把下一层的子节点保存到另一层的栈里
* 奇数层和偶数层保存左右子节点的顺序不同
* 使用一个int变量index作为开关，取值为0或1在2个栈之间切换

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int> > res;
        if(!pRoot)
            return res;
        
        stack<TreeNode*> st[2];
        int index = 0;//0的栈存从左到右的节点，1存从右到左
        st[index].push(pRoot);
        
        TreeNode* curr;
        vector<int> linevec;
        while(!st[index].empty()){
            curr = st[index].top();
            st[index].pop();
            linevec.push_back(curr->val);
            
            if(!index){
                if(curr->left)
                    st[1-index].push(curr->left);
                if(curr->right)
                    st[1-index].push(curr->right);
            }
            else{
                if(curr->right)
                    st[1-index].push(curr->right);
                if(curr->left)
                    st[1-index].push(curr->left);
            }
            
            //如果是最后一个元素
            if(st[index].empty()){
                index = 1 - index;
                res.push_back(linevec);
                linevec.clear();
            }
        }
        
        return res;
    }
};
```

<br>
<br>

## 二叉树的镜像

[OJ链接](https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

操作给定的二叉树，将其变换为源二叉树的镜像

例如：

```
      8
     /  \
    6   10
   / \  / \
  5  7 9 11

对应的镜像为：

      8
     /  \
    10   6
   / \  / \
  11 9 7  5
```

### 解答

#### 1）迭代

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        stack<TreeNode*> st;
        if(pRoot)
            st.push(pRoot);
        
        TreeNode *curr,*tp;
        while(!st.empty()){
            curr = st.top();
            st.pop();
            
            tp = curr->left;
            curr->left = curr->right;
            curr->right = tp;
            
            if(curr->left)
                st.push(curr->left);
            if(curr->right)
                st.push(curr->right);
        }
    }
};
```

<br>
<br>

## 对称的二叉树

[OJ链接](https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=3&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一个二叉树，检查它是否是镜像对称的

例如，二叉树 [1,2,2,3,4,4,3] 是对称的

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

### 解答

#### 1）递归

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)   return true;
        
        TreeNode *nd1 = root->left,*nd2 = root->right;
        return equalNode(nd1,nd2);
    }
    
private:
    bool equalNode(TreeNode* nd1,TreeNode* nd2){
        if(!nd1)    return !nd2;
        if(!nd2)    return false;
        
        if(nd1->val == nd2->val)
            return equalNode(nd1->left,nd2->right) && equalNode(nd1->right,nd2->left);
        return false;
    }
};
```

#### 2）迭代

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)   return true;
        
        stack<TreeNode*> s;
        s.push(root->left);
        s.push(root->right);
        while(!s.empty()){
            TreeNode *nd1 = s.top();
            s.pop();
            TreeNode *nd2 = s.top();
            s.pop();
            if(!nd1 && !nd2)    continue;
            else if(!nd1 && nd2)    return false;
            else if(nd1 && !nd2)    return false;
            else if(nd1->val != nd2->val)   return false;
            s.push(nd1->left),s.push(nd2->right);
            s.push(nd1->right),s.push(nd2->left);
        }
        
        return true;
    }
};
```

<br>
<br>

## 二叉树中和为某一值的路径

[OJ链接](https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径

### 解答

当用前序遍历的方式访问到某一节点时，把该节点添加到路径(vector)上，并累加该节点的值

* 如果节点为叶节点，并且路径中节点值的和刚好等于输入的整数，则当前路径符合要求，打印出来
* 如果不是叶节点，继续访问子节点

当前节点访问结束后，递归函数将自动回到它的父节点。因此，在函数退出之前要在路径上删除当前节点并减去当前节点的值，以确保返回父节点时路径刚好是从根节点到父节点

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
        vector<vector<int>> pathArr;
        if(!root)
            return pathArr;
        
        vector<int> path;
        FindPathCore(root,expectNumber,path,pathArr);
        return pathArr;
    }
    
    void FindPathCore(TreeNode* nd,int expectNumber,
                      vector<int> &path,vector<vector<int>> &pathArr){
        if(!nd)
            return;
        
        path.push_back(nd->val);
        expectNumber -= nd->val;
        
        if(nd->left)
            FindPathCore(nd->left,expectNumber,path,pathArr);
        if(nd->left)
            FindPathCore(nd->right,expectNumber,path,pathArr);
        
        if(!nd->left && !nd->right && expectNumber == 0){
            pathArr.push_back(path);
        }
        
        path.pop_back();
    }
};
```

<br>
<br>

## 二叉树的最大路径和

[OJ链接](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/)

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

示例 1:

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

示例 2:

```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```

### 解答

对于一棵root为根节点的树，假设其左子树(含左子节点)的最大路径为maxLeft，右子树(含右子节点)的最大路径为maxRight：

* 如果maxLeft小于等于0，那么不含入左子节点（也就是说将路径从左子节点处切断），可以得到一个更大的路径
* 如果maxRight小于等于0，那么不含入右子节点（也就是说将路径从右子节点处切断），可以得到一个更大的路径
* 如果两者都大于0，那么连通左右子树可以得到一个更大的路径

因此，根据上面几种情况，可以得到一个“局部最大”的路径。局部最大是因为这个路径包含了root节点。但是全局最大的路径不一定包含root节点。因此需要一个全局最大路径的变量res，如果res小于这个局部最大路径，那么更新res

那么maxLeft和maxRight应该怎么得到，也就是函数应该返回什么？注意上面对maxLeft和maxRight的描述中，这两个都包含了左右子树的根节点，因此，返回值不是res。那么是不是这个局部最大的路径？也不是，因为局部最大的路径可能连通了左右子树，比如上面示例2中以20为根节点的树。因此，这个返回值是一个单边路径，也就是说，如果maxLeft和maxRight都小于0，那么只返回根节点的值（路径只包含 根节点），否则，返回maxLeft和maxRight中较大者加上根节点的值

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxPathSum(TreeNode* root) {
        int res = INT_MIN;
        maxPathSum(root,res);
        
        return res;
    }
private:
    int maxPathSum(TreeNode* root,int &res) {
        if(!root)   return 0;
        
        int max;
        int leftMax = maxPathSum(root->left,res);
        int rightMax = maxPathSum(root->right,res);
        if(leftMax <= 0 && rightMax <= 0)   //两边都小于等于0
            max = root->val;
        else if(leftMax <= 0 || rightMax <= 0) //有一边大于0，另一边小于等于0
            max = leftMax > rightMax ? leftMax + root->val : rightMax + root->val;
        else //两边都大于0
            max = leftMax + rightMax + root->val;
        
        if(max > res)   res = max;
        
        if(leftMax <= 0 && rightMax <= 0)   //两边都小于等于0
            return root->val;
        else    //至少有一边大于0
            return leftMax > rightMax ? leftMax + root->val : rightMax + root->val;
    }
};
```

<br>
<br>

## 二叉树的深度

[OJ链接](https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度

### 解答

* 如果没有左右子树，深度为1
* 如果只有左子树，深度为左子树深度加1
* 如果只有右子树，深度为右子树深度加1
* 如果都有，深度为左子树和右子树深度较大者加1

```c++
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(!pRoot)
            return 0;
        
        int depth1 = 1 + TreeDepth(pRoot->left);
        int depth2 = 1 + TreeDepth(pRoot->right);
        
        return depth1 > depth2 ? depth1 : depth2;
    }
};
```

<br>
<br>

## 平衡二叉树AVL

[OJ链接](https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一棵二叉树，判断该二叉树是否是平衡二叉树

### 解答

#### 1）方法一

遍历AVL的每个节点，求该节点左右子树的高度，如果差不超过1，则继续递归，判断左右子树是不是AVL

这种方法求深度时某些节点的深度会重复计算，效率低

#### 2）方法二

后续遍历，遍历到一个节点时已经遍历了它的左右子树，只要在遍历每个节点的时候记录它的深度，就可以一边遍历一边判断每个节点是不是平衡的

```c++
class Solution {
public:
    bool IsBalanced_Solution(TreeNode* pRoot) {
        int depth;
        return IsBalanced_Solution(pRoot,depth);
    }
private:
    bool IsBalanced_Solution(TreeNode* pRoot,int &depth){
        if(!pRoot){
            depth = 0;
            return true;
        }
        int depth_l,depth_r;
        if(!IsBalanced_Solution(pRoot->left,depth_l) || 
            !IsBalanced_Solution(pRoot->right,depth_r) ||
            abs(depth_l - depth_r) > 1)
            return false;
        depth = max(depth_l,depth_r) + 1;
        return true;
    }
};
```

<br>
<br>

## 两个节点的最低公共祖先

### 题目一：BST中两个节点的最低公共祖先

**解答**：从树的根节点开始和两个输入的节点进行比较。如果当前节点的值比两个节点的值都大，那么最低的共同父节点一定在当前节点的左子树中，于是下一步遍历当前节点的左子节点；如果当前节点的值比两个节点的值都小，那么最低的共同父节点一定在当前节点的右子树中，于是下一步遍历当前节点的右子节点；这样，在树中从上到下找到的第一个在两个输入节点的值之间的节点就是最低的公共祖先

### 题目二：树，节点存在指向父节点的指针

**解答**：可以转化为求两个链表的第一个公共节点的问题

### 题目三：二叉树，节点不存在指向父节点的指针

[OJ链接](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

例如，给定如下二叉树:  `root = [3,5,1,6,2,0,8,null,null,7,4]`

```
        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
```

示例 1:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

示例 2:

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

说明:

* 所有节点的值都是唯一的
* p、q 为不同节点且均存在于给定的二叉树中

### 解答

> 解法同[题目四](#题目四非二叉树节点不存在指向父节点的指针)

以下为获取2条路径的解法：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root || !p || !q)   return NULL;
        if(p == q)  return p;
        
        vector<vector<TreeNode*>> paths;
        vector<TreeNode*> path;
        
        preOrderTraversal(root,p,q,paths,path);
        
        if(paths.size() != 2)   return NULL;
        
        int i = 0,j = 0;
        while(paths[0][i + 1] == paths[1][j + 1])   i++,j++;
        
        return paths[0][i];
    }
private:
    void preOrderTraversal(TreeNode *root,TreeNode *p,TreeNode *q,
                           vector<vector<TreeNode*>> &paths,vector<TreeNode*> &path)
    {
        if(!root)   return;
        
        path.push_back(root);
        if(root == p)   paths.push_back(path);
        else if(root == q)  paths.push_back(path);
        if(root->left)  preOrderTraversal(root->left,p,q,paths,path);
        if(root->right) preOrderTraversal(root->right,p,q,paths,path);
        path.pop_back();
    }
};
```

### 题目四：非二叉树，节点不存在指向父节点的指针

**解法一(不使用辅助内存，效率低)**：从根节点开始，判断两个节点是否都在该树中，如果都在则判断两个节点是否都在根节点的子树中，如果两个节点都在以根节点的某个子节点为根节点的子树中，则继续递归判断，按这个过程一直处理，当以某个节点node为根节点的子树中包含2个节点，并且node的任一子节点都不同时包含两个节点时，这个node就是最低公共祖先

**解法二(使用辅助内存，效率高)**：用两个链表，保存从根节点到输入的两个节点的路径，然后把问题转换成求两个链表的最后最后公共节点

<br>
<br>

## 用两个栈实现队列

[OJ链接](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=4&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型

### 解答

* **入队**：插入stack1
* **出队**：如果stack2为空，从stack1弹出并压入stack2，最后弹出stack2栈顶。如果stack2不为空，直接弹出​stack2栈顶

```c++
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        if(stack2.empty())
            throw new exception();
        int front;
        front = stack2.top();
        stack2.pop();
        return front;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

<br>
<br>

## 用两个队列实现栈

如题

### 解答

**插入**：元素插入包含元素的队列

**删除(弹出栈顶)**：将包含n个元素的队列前n-1个元素移入另一个空队列，取出第n个元素

> 删除的时间复杂度并不是O(1)

<br>
<br>

## 包含min函数的栈

[OJ链接](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=4&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数

### 解答

使用一个栈保存最小元素，最小栈的栈顶元素是当前栈中所有元素的最小元素

为了保证每次压入新元素时，最小栈的栈顶也压入新的最小值，只需要比较新压入元素与最小栈栈顶元素的大小

* 如果新元素小于最小栈的栈顶元素，那么新元素小于当前栈中的最小元素，则将新元素压入最小栈
* 否则，压入新值并没有用改变栈的最小值，那么继续往最小栈中压入最小栈的栈顶元素

```c++
class Solution {
public:
    void push(int value) {
        dataStack.push(value);
        if(minStack.empty() || !minStack.empty() && value < minStack.top()){
            minStack.push(value);
        }
        else
            minStack.push(minStack.top());
    }
    void pop() {
        if(dataStack.empty())
            throw new exception();
        dataStack.pop();
        minStack.pop();
    }
    int top() {
        if(dataStack.empty())
            throw new exception();
        return dataStack.top();
    }
    int min() {
        if(dataStack.empty())
            throw new exception();
        return minStack.top();
    }
private:
    stack<int> dataStack;
    stack<int> minStack;
};
```

<br>
<br>

## 包含max函数的队列

请定义一个队列并实现函数max得到队列里的最大值，要求函数max、push_back和pop_front的时间复杂度都是O(1)

### 解答

队列类包含2个队列成员和1个下标成员。2个队列成员中，一个保存数据，一个保存最大值。最大值队列运用了[滑动窗口](#滑动窗口的最大值)的思想，首元素最大。两个队列中保存的元素都是一个类型，该类型包含元素值和元素的下标，只有当数据队列首部出队的元素下标和最大值队列首部的最大值元素是同一元素（下标相同）时，最大值才出队

<br>
<br>

## 栈的压入弹出序列

[OJ链接](https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=2&rp=4&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。

例如：序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

### 解答

* 如果下一个弹出的数字刚好是栈顶数字，那么直接弹出
* 如果下一个弹出的数字不是栈顶数字，则把压栈序列中还没有入栈的数字压入栈中，直到把下一个需要弹出的数字压入栈顶为止
* 如果所有数字都压入栈后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列

```c++
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        if(pushV.size() != popV.size())
            return false;
        
        stack<int> st;
        int i = 0;
        for(int e : popV){
            if(!st.empty() && st.top() == e){
                st.pop();
                continue;
            }
            while(i < pushV.size() && pushV[i] != e){
                st.push(pushV[i]);
                i++;
            }
            if(i == pushV.size())
                return false;
            i++;
        }
        
        return true;
    }
};
```

<br>
<br>

## 滑动窗口的最大值

[OJ链接](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=4&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值

例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}

### 解答

使用一个两端队列，队列头部始终保存当前滑动窗口最大值

对于数组中任意元素，从尾部向前比较，如果该元素大于尾部元素，则从队列尾部删除，一直删除完所有比新元素小的元素，然后从尾部插入新元素(的下标)

由于新元素不一定比首元素大，如果首元素刚好从滑动窗口移除时，也要删除首元素，所以在完成上述操作后，也要判断首元素是否已经脱离滑动窗口

因为要判断队首元素是否脱离滑动窗口，所以队列存的是元素的下标，同时要从首部删除，所以使用双端队列

```c++
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> res;
        if(size > num.size())
            return res;
        
        deque<int> dq;
        int sz = num.size();
        for(int i = 0;i < sz;i++){
            while(dq.size() > 0 && num[dq.back()] < num[i])
                dq.pop_back();
            dq.push_back(i);
            if(i - dq.front() + 1 > size)
                dq.pop_front();
            if(i >= size - 1)
                res.push_back(num[dq.front()]);
        }
        
        return res;
    }
};
```

<br>
<br>

## 斐波那契数列

[OJ链接](https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个整数n，请你输出斐波那契数列的第n项

### 解答

斐波那契数列第n项的和取决于第n-1项的和还有第n-2项的和，即状态转移方程为：`f(n) = f(n-1) + f(n - 2)`（`f(0) = 0` `f(1) = 1`）

```c++
class Solution {
public:
    int Fibonacci(int n) {
        if(n <= 0)
            return 0;
        
        if(n == 1)    return 1;
        
        int num1 = 0,num2 = 1;
        int res;
        for(int i = 2;i <= n;i++){
            res = num1 + num2;
            num1 = num2;
            num2 = res;
        }
        
        return res;
    }
};
```

<br>
<br>

## 跳台阶

[OJ链接](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法

### 解法

第一次可以选择跳1级也可以跳2级，因此 `f(n) = f(n-1) + f(n - 2)`，就是求斐波那契数列

```c++
class Solution {
public:
    int jumpFloor(int number) {
        if(number < 1)
            return 0;
        if(number == 1)
            return 1;
        
        int num1 = 1,num2 = 1;
        int res;
        for(int i = 2;i <= number;i++){
            res = num1 + num2;
            num1 = num2;
            num2 = res;
        }
        
        return res;
    }
};
```

<br>
<br>

## 变态跳台阶

[OJ链接](https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法

### 解答

第一次可以选择跳`1`级或`2`级...或`n`级，那么 `f(n) = f(n - 1) + f(n - 2) + ... + f(0)`，可以进一步求得`f(n) = 2f(n-1)`，因为`f(1) = 1`，故`f(n) = 2^(n - 1)`

> 这个题实际上是一个延伸扩展，并不属于斐波那契数列

```c++
class Solution {
public:
    int jumpFloorII(int number) {
        if(number <= 0)
            return 0;
        
        if(number == 1)
            return 1;
        
        int res = 1;
        for(int i = 2;i <= number;i++){
            res *= 2;
        }
        
        return res;
    }
};
```

<br>
<br>

## 矩形覆盖

[OJ链接](https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

我们可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*1的小矩形无重叠地覆盖一个2\*n的大矩形，总共有多少种方法？

### 解答

假设总的放法为f(n)

* 如果第一个竖着放，则需要求f(n-1)
* 如果第一个横着放，那么这个矩形下面也必须横着放，需要求f(n-2)

故 `f(n) = f(n-1) + f(n-2)`，即求斐波那契数列的第n项

```c++
class Solution {
public:
    int rectCover(int number) {
        if(number <= 0)
            return 0;
        if(number == 1)
            return 1;
        
        /*
         * 使用num1和num2存储F(M-1)和F(M-2)，自底向上计算
         */
        int res;
        int num1 = 1,num2 = 1;
        for(int i = 2;i <= number;i++){
            res = num1 + num2;  //求出F(M)
            num1 = num2;        //使用F(M-1)更新F(M-2)
            num2 = res;         //使用F(M)更新F(M-1)
        }
        
        return res;
    }
};
```

<br>
<br>

## 二进制中1的个数

[OJ链接](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示

### 解答

#### 1）方法一

首先把n和1做与运算，判断n的最低位是不是为1。接着把1左移一位得到2，再和n做与运算...（循环次数等于整数二进制的位数。unsigned int flag = 1）

#### 2）方法二

一个整数减去1之后再和原来的整数做位与运算，得到的结果相当于把整数二进制表示中最右边的1变成0；（有多少个1就循环多少次）

```c++
class Solution {
public:
     int  NumberOf1(int n) {
         int count = 0;
         
         while(n){
            n = (n - 1) & n;
            count++;
         }
         
         return count;
     }
};
```

<br>
<br>

## 数值的整数次方

OJ链接：[牛客](https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=3&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)、[Leetcode](https://leetcode.com/problems/powx-n/description/)（Leetcode上要求更高）

给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方

### 解答

* 当x为0时？
* 当n为0时？
* 当n为INT_MAX和**INT_MIN**时？

#### 1）方法一

循环n次，每次乘以x

**时间复杂度**：O(n)

#### 2）方法二

使用一个变量m表示指数，如果`m*2<n`，则将结果平方，由于每次指数增长，所以比线性增长快很多

```c++
class Solution {
public:
    double myPow(double x, int n) {
        bool b = n < 0;
        
        if(x == 0)  return 0;
        if(n == 0)  return 1;
        
        //需要使用一个long long类型的变量，因为当n为INT_MIN时，和-1乘会溢出
        long long nl = n < 0 ? (long long)n * -1 : n;
        double ret = 1.0;
        
        while(nl){
            long long m = 1;//m必须也是long long,因为当m = INT_MAX/2+1时，计算m*2会溢出
            double tp = x;
            while(2 * m <= nl){
                tp *= tp;
                m *= 2;
            }
            nl = nl - m;
            ret *= tp;
        }
        
        ret = b ? 1 / ret : ret;
        return ret;
    }
};
```

**时间复杂度**：O(logn)

#### 3）方法三

假设`n`为`19(0010011)`，那么求出`x^1`、`x^2`、`x^16`次方就行了:

```
res = x^1 * x^2 * x^16
```

`res`初始化为`x^1`，求出`x^2`和`x^16`时，再分别与`res`相乘

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if(x == 0)  return 0;
        if(n == 0)  return 1;
        
        long long nl = n;
        bool negative = nl < 0;
        if(negative)    nl = nl * -1;
        
        while((nl & 1) == 0){
            nl >>= 1;
            x *= x;
        }
        
        double res = x;
        nl >>= 1;
        
        while(nl){
            x *= x;
            if((nl & 1) == 1) res *= x;
            nl >>= 1;
        }
        
        if(negative)    return 1 / res;
        return res;
    }
};
```

<br>
<br>


## 整数1~n中1出现的次数

[OJ链接](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数

### 解答

每次截去最高位作为划分，递归处理

如：`n=21345`，分成2段：

* `20001~21345`（因为此时最高位已经固定，所以等同于求`1~1345`中1出现的次数）
* `0~20000`

第一部分的次数递归处理；对于第二部分，当1在最高位时，因为范围包括了以1为最高位的所有5位数（`10000~19999`），所有总共出现`10^(位数-1)`次​，如果是到11345，则不包括所有以1位最高位的5位数，因此只出现`1345+1`次。当1在其余4位时，​出现`最高位数字*(10^(位数-2))*(位数-1)`次

```c++
class Solution {
public:
    int powerbase10(unsigned int n){
        int res = 1;
        while(n){
            res *= 10;
            n--;
        }
        return res;
    }
    
    int NumberOf1Between1AndN(const string &str,int index){
    if(str.size() == 0)    return 0;
    if(index == static_cast<int>(str.size()) - 1){
        if(str[index] == '0')
            return 0;
        return 1;
    }

    if(stoi(str.substr(index)) == 0)
        return 0;

    int count1,countOther;
    int length = str.size() - index;
    int firstDigit = str[index] - '0';

    if(firstDigit == 1)
        count1 = stoi(str.substr(index + 1)) + 1;
    else//大于1
        count1 = powerbase10(length - 1);

    countOther = firstDigit * (length - 1) * powerbase10(length - 2);
    int countRecursive = NumberOf1Between1AndN(str,index + 1);

    return count1 + countOther + countRecursive;
}
    
    int NumberOf1Between1AndN_Solution(int n)
    {
        string s = to_string(n);
        
        return NumberOf1Between1AndN(s,0);
    }
};
```

<br>
<br>

## 丑数

[OJ链接](https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把只包含因子2、3和5的数称作丑数（Ugly Number）

例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数

### 解答

丑数的判断：如果能被2整除，就连续除以2。如果能被3整除，就连续除以3。如果能被5整除，就连续除以5。如果最后得到的是1，这个数就是丑数，否则不是；

#### 1）方法一

从1开始逐个判断

> 不是丑数的数也会进行判断，有多余时间开销

#### 2）方法二

创建数组nums保存已经找到的丑数，维护3个下标idx1、idx2、idx3

* 因此下一个丑数是`min(nums[idx1] * 2,nums[idx2] * 3,nums[idx3] * 5)`

每得到一个新的丑数，相应的下标加1，其余2个下标不变

> 空间换时间，一个丑数应该是另一个丑数乘以2，3或5的结果

```c++
class Solution {
public:
    int minInTree(const int &a,const int &b,const int &c){
        if(a < b)
            return a < c ? a : c;
        else
            return b < c ? b : c;
    }
    int GetUglyNumber_Solution(int index) {
        if(index <= 0)//如果下标非法，返回0
            return 0;
        vector<int> uglyNumberArr;
        uglyNumberArr.push_back(1);
        
        int idx2 = 0,idx3 = 0,idx5 = 0,curr = 0;
        while(curr != index - 1){
            while(uglyNumberArr[idx2] * 2 <= uglyNumberArr[curr]) {idx2++;}
            while(uglyNumberArr[idx3] * 3 <= uglyNumberArr[curr]) {idx3++;}
            while(uglyNumberArr[idx5] * 5 <= uglyNumberArr[curr]) {idx5++;}
            
            uglyNumberArr.push_back(minInTree(uglyNumberArr[idx2] * 2,uglyNumberArr[idx3] * 3,uglyNumberArr[idx5] * 5));
            curr++;
        }
        
        return uglyNumberArr[curr];
    }
};
```

<br>
<br>

## 求1~n的和

[OJ链接](https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）

### 解答

#### 1）利用构造函数

设计一个类，拥有1个静态int成员，初始值为0，构造函数每次将该静态成员加1，因此，创建n个对象即可

#### 2）递归

使用`&&`作为终止判断

```c++
class Solution {
public:
    int Sum_Solution(int n) {
        int ret = n;
        ret && (ret = n + Sum_Solution(n - 1));
        return ret;
    }
};
```

<br>
<br>

## 不用加减乘除做加法

[OJ链接](https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=3&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、\*、/四则运算符号

### 解答

两数异或，会得到两数相加时忽略所有进位的结果，然后两数位与的结果左移1位，得到所有进位组成的数字，再对这两个结果重复上述步骤，直至没有进位

```c++
class Solution {
public:
    int Add(int num1, int num2)
    {
        int res = num1 ^ num2;
        int jw = (num1 & num2) << 1;
        
        int tp;
        while(jw){
            tp = res;
            res = res ^ jw;
            jw = (tp & jw) << 1;
        }
        
        return res;
    }
};
```

<br>
<br>

## 不用乘除取模实现整数除法

[OJ链接](https://leetcode.com/problems/divide-two-integers/description/)

给定两个整数，被除数 `dividend` 和除数 `divisor`。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 `dividend` 除以除数 `divisor` 得到的商。

示例 1:

```
输入: dividend = 10, divisor = 3
输出: 3
```

示例 2:

```
输入: dividend = 7, divisor = -3
输出: -2
```

说明:

* 被除数和除数均为 32 位有符号整数。
* 除数不为 0。
* 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1

### 解答

#### 1）方法一

循环递减，每次减去除数，直到小于除数，记录次数

> 效率低，时间开销大

#### 2）方法二

如果被除数比除数的2倍大，则将除数变为当前值的2倍（因此，次数也成倍增加），直到被除数小于除数的2倍。然后将被除数减去除数，处理剩下的值，例如被除数为15，除数为2，有下列过程：

* 15大于2，因此初始化计数为1
* 由于15大于4(2<<1)，那么15里面肯定包含2个2，计数翻倍，变为2
* 由于15大于8(4<<1)，那么15里面肯定包含4个2，计数翻倍，变为4
* 由于15小于16(8<<1)，说明15不可能包含8个2，因此15减去8(4个2)，变为7
* 同样，对7进行上面的处理，新一轮计数为2（7包含2个2，不能包含4个2），因此总计数为6，将7减去4
* 对3进行上面的处理，这一轮计数为1，因此总计数变为7，将3减去2
* 对1进行上述处理，由于1小于2，所以停止
* 因此，15里面包含7个2，即商为7

> 由于每次将除数翻倍，所以会比方法一快很多

```c++
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor == 0 || dividend == INT_MIN && divisor == -1)
            return INT_MAX;
        
        bool negative = !((dividend < 0 && divisor < 0) || (dividend > 0 && divisor > 0));
        long long dvd = labs(dividend);
        long long dvs = labs(divisor);
        
        long long res = 0 ;
        while(dvd >= dvs){
            long long tp = dvs;
            long long count = 1;
            while(dvd >= (tp << 1)){
                count <<= 1;
                tp <<= 1;
            }
            res += count;
            dvd -= tp;
        }
        
        res = negative ? res * -1 : res;
        return res;
    }
};
```

<br>
<br>

## 求分数的值

[OJ链接](https://leetcode.com/problems/fraction-to-recurring-decimal/description/)

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字符串形式返回小数。

如果小数部分为循环小数，则将循环的部分括在括号内。

示例 1:

```
输入: numerator = 1, denominator = 2
输出: "0.5"
```

示例 2:

```
输入: numerator = 2, denominator = 1
输出: "2"
```

示例 3:

```
输入: numerator = 2, denominator = 3
输出: "0.(6)"
```

### 解答

首先将分子和分母都转化为正数（由于最小负整数转化成正整数会越界，所以使用long long），并且记录结果是否是负数

计算得出整数部分，根据是否存在余数决定有没有小数点

如果有余数，则处理小数部分：

* 使用map判断是否出现循环，map的key为除数，value为对应的小数部位的下标
    - 如果出现循环，则停止处理
    - 否则，向map中添加新项，并且向结果字符串尾部添加除得的商
* 根据最终余数是否为0判断在处理小数部分时，是否出现循环，出现则添加括号

```c++
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        if(denominator == 0)    return "";
        if(numerator == 0)  return "0";
        
        bool negative = (numerator < 0) ^ (denominator < 0);
        long long lnumerator = abs((long long)numerator);
        long long ldenominator = abs((long long)denominator);
        unordered_map<int,int> map;//<numerator,index>
        string res = (negative ? "-" : "") + to_string(lnumerator / ldenominator) + (lnumerator % ldenominator ? "." : "");
        lnumerator = lnumerator % ldenominator; 
        
        while(lnumerator && map.find(lnumerator) == map.end()){
            map[lnumerator]=res.size();
            lnumerator *= 10;
            res = res + to_string(lnumerator / ldenominator);
            lnumerator = lnumerator % ldenominator;
        }
        
        if(lnumerator){
            int idx = map.find(lnumerator)->second;
            res = res.substr(0,idx) + "(" + res.substr(idx) + ")";
        }
        
        return res;
    }
};
```

<br>
<br>