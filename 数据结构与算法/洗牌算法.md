> 洗牌中“乱”的定义应该是：对于一副54张牌的扑克，有54!中排序方式。洗牌算法应该能等概率地生成这54!种结果中的一种

Fisher–Yates shuffle洗牌算法的思想是，每次从未处理的牌中随机选择一个，与未处理牌中最后一张牌交换，从而打乱顺序。算法本身没有保证在取每个随机数的时候是等概率的，它保证的是可以等概率的生成给定数组的任一排列。对于n张牌的数组，处理过程如下：

* 第一次：从[0,n-1]中，随机选择一个位置k1，交换位置k1和位置n-1的元素
* 第二次：从[0,n-2]中，随机选择一个位置k2，交换位置k2和位置n-2的元素
* ...

当需要将一个数组(整形,字符...)中元素的顺序打乱时，可以使用Fisher–Yates shuffle洗牌算法

```c++
const int number = 54;  //牌总数

void shuffle(vector<unsigned int> &plates){
    //根据时间设置随机数种子
    srand((unsigned int)time(0));

    int k,tp;
    for(int i = number - 1;i >= 1;i--){
        //在0~i中得到一个随机数
        k = rand() % (i + 1);
        //交换plates[i]和plates[k]
        tp = plates[i];
        plates[i] = plates[k];
        plates[k] = tp;
    }
}

int main()
{
    vector<unsigned int> plates;
    for(int i = 1;i <= number;i++)
        plates.push_back(i);

    shuffle(plates);//洗牌

    for(auto e : plates)
        cout << e << " ";
    cout << endl;
}
```