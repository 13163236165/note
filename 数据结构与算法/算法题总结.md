> 题目来源：《剑指offer》、leetcode、lintcode、hihocoder、《王道程序员求职宝典》

* **一.数组**
    - *连续子数组*
        + 《剑指offer》面试题42：[连续子数组的最大和](#连续子数组的最大和)（`动态规划`）
        + Leetcode152：[连续子数组的最大积](#连续子数组的最大积)（`动态规划`）
* **二.字符串**
    - *字符串匹配*
        + Leetcode10：[正则表达式匹配](#正则表达式匹配)（`动态规划`）
        + Leetcode44：[通配符匹配](#通配符匹配)（`动态规划`）
    - *公共子串和公共子序列*
        + Lintcode77：[两个字符串的最长公共子序列](#两个字符串的最长公共子序列)（`动态规划`）
        + Lintcode79：[两个字符串的最长公共子串](#两个字符串的最长公共子串)（`动态规划`）
* **三.链表**
* **四.树**
* **五.栈和队列**
* **六.数学**
* **七.图**
* **八.海量数据**
* **九.其它**


<br>
<br>
<br>
<br>
<br>
<br>
<br>

## 连续子数组的最大和

[OJ链接](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 解答

令sum[i]表示所有以位置i的元素结尾的连续子数组的最大和，状态转移方程如下：

* 当 `sum[i] <= 0` 时，`sum[i+1] = array[i + 1]`
* 当 `sum[i] > 0` 时，`sum[i+1] = sum[i] + array[i + 1]`

那么连续子数组的最大和，就是`max{sum[0],sum[1],...,sum[n-1]}`

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.size() == 0)   return 0;

        int sum = array[0],res = array[0];
        int sz = array.size();
        for(int i = 1;i < sz;i++){
            if(sum > 0)    sum += array[i];
            else           sum = array[i];
            if(sum > res)  res = sum;
        }
        
        return res;
    }
};
```

<br>

## 连续子数组的最大积

[OJ链接](https://leetcode.com/problems/maximum-product-subarray/description/)

给定一个整数数组 `nums` ，找出乘积最大的连续子数组（该数组至少包含一个数）

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是连续子数组。
```

### 解答

假设`max_local[i]`表示以`nums[i]`结尾的连续子数组的最大积，如果能求出所有`max_local`，那么最大者就是答案

现在看怎么求`max_local[i]`：

* 如果`max_local[i - 1]`为`0`
    - 当`nums[i]`大于等于`0`时，`max_local[i] = nums[i]`，与前面的子数组无关
    - 当`nums[i]`小于`0`时，`max_local[i] = 0`
* 否则，如果`nums[i]`与`max_local[i - 1]`符号相同，那么`max_local[i] = nums[i] * max_local[i - 1]`，此时将前面的连续子数组并入
* 否则，如果`nums[i]`与`max_local[i - 1]`符号不同，那么`nums[i] * max_local[i - 1]`是以`nums[i]`结尾的连续子数组的最小积，设为`min_local[i]`，如果知道`min_local[i - 1]`，那么就能求出`max_local[i]`：`max_local[i] = min_local[i - 1] * nums[i]`

因此，要求出max_local[i]，同时需要维护连续子数组的最小积——`min_local`数组，对上面的分析进行总结：因为`nums[i]`可能与`max_local[i - 1]`同号，可能异号，`max_local[i - 1]`也可能为`0`。所以`max_local[i]`取决于3个值：`max_local[i - 1]*nums[i]`、`min_local[i - 1]*nums[i]`、`nums[i]`（隐含了状态转移方程）

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.empty())    return 0;
        
        int max_global = nums[0];
        int max_local = nums[0],min_local = nums[0];
        
        for(int i = 1;i < nums.size();i++){
            int _max = max(max_local * nums[i],min_local * nums[i],nums[i]);
            int _min = min(max_local * nums[i],min_local * nums[i],nums[i]);
            max_local = _max;
            min_local = _min;
            if(max_local > max_global)  max_global = max_local;
        }
        
        return max_global;
    }
private:
    int max(int num1,int num2,int num3){
        return num1 > num2 ? (num1 > num3 ? num1 : num3) : (num2 > num3 ? num2 : num3); 
    }
    
    int min(int num1,int num2,int num3){
        return num1 < num2 ? (num1 < num3 ? num1 : num3) : (num2 < num3 ? num2 : num3);
    }
};
```

<br>

## 正则表达式匹配

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
```

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

示例 3:

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

示例 4:

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

示例 5:

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 解答

**动态规划**

创建一个二维矩阵记录状态。`state[i][j]`表示`s[0~i-1]`能否和`p[0~j-1]`匹配：

* 如果`p[j - 1] == '*'`，此时`p[j - 2]`可以使用也可以不使用
    - 如果使用，`state[i][j] = ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j])`
    - 如果不使用，`state[i][j] = state[i][j - 2]`
* 如果`p[j - 1] == '.'`，此时`state[i][j] = state[i - 1][j - 1]`
* 否则，`state[i][j] = p[j - 1] == s[i - 1] && state[i - 1][j - 1]`

**注意二维bool矩阵的创建方法，这里不要使用vector**

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        bool **state = new bool*[len1 + 1];
        for(int i = 0;i <= len1;i++)
            state[i] = new bool[len2 + 1];
        
        //第一列，p = ""
        state[0][0] = true;
        for(int i = 1;i <= len1;i++)    state[i][0] = false;
        
        //第一行，s = ""
        state[0][1] = false;
        for(int j = 2;j <= len2;j++)    state[0][j] = (p[j - 1] == '*') ? (state[0][j - 2]) : false;
        
        for(int i = 1;i <= len1;i++)
            for(int j = 1;j <= len2;j++){
                if(p[j - 1] == '*')
                    state[i][j] = state[i][j - 2] || ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j]);
                else if(p[j - 1] == '.')
                    state[i][j] = state[i - 1][j - 1];
                else
                    state[i][j] = (p[j - 1] == s[i - 1]) && state[i - 1][j - 1];
            }
        
        return state[len1][len2];
    }
};
```

<br>

## 通配符匹配

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

示例 3:

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

示例 4:

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

示例 5:

```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

### 解答

使用动态规划

给出字符串s，和字符串模板p。假设matches\[0\]\[0\]表示s和p是否能匹配。可以根据p[0]进行分析：

* 如果p[0]==‘\*’，那么可以选择\*匹配一个字符，或者不匹配。如果匹配一个字符，那么matches\[0\]\[0\]取决于s.substr[1]与p是否匹配；如果\*不匹配一个字符，那么matches\[0\]\[0\]取决于s与p.substr[1]是否匹配。即matches\[0\]\[0\] = matches\[1\]\[0\] || matches\[0\]\[1\]
* 如果p[0]=='?'，那么必须匹配一个字符，因此matches\[0\]\[0\] = matches\[1\]\[1\]
* 否则，matches\[0\]\[0\] = s\[0\] == p\[0\] && matches\[1\]\[1\]

因此可以根据上面3种情况得到状态转移方程

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        vector<vector<char>> matches(len1 + 1,vector<char>(len2 + 1));
        for(int i = 0;i < len1;i++)  // p == ""
            matches[i][len2] = 0;
        matches[len1][len2] = 1;       // p == "" && s == ""
        for(int j = len2 - 1;j >= 0;j--) // s == ""
            matches[len1][j] = (p[j] == '*' && matches[len1][j + 1]);
        
        for(int i = len1 - 1;i >= 0;i--){ // s.substr[i] match p.substr[j] ?
            for(int j = len2 - 1;j >= 0;j--){
                if(p[j] == '?')
                    matches[i][j] = matches[i + 1][j + 1];
                else if(p[j] == '*')
                    matches[i][j] = matches[i + 1][j] || matches[i][j + 1];
                else
                    matches[i][j] = (s[i] == p[j] && matches[i + 1][j + 1]);
            }
        }
        
        return matches[0][0];
    }
};
```

<br>

## 两个字符串的最长公共子序列

[OJ链接](https://www.lintcode.com/problem/longest-common-subsequence/description)

给出2个字符串，找出它们的最长公共子序列（LCS）。返回其长度

例子：

* For `"ABCD"` and `"EDCA"`, the LCS is `"A"` (or `"D"`, `"C"`), return `1`.
* For `"ABCD"` and `"EACB"`, the LCS is `"AC"`, return `2`.

### 解答

假设两个字符串序列为X和Y，从结尾字符进行分析（设`n`和`m`为两个字符串的长度）：

* 如果结尾字符相等，那么问题转换为求序列`X(n-1)`和`Y(m-1)`的最长公共子序列，即：`LCS(X(n-1),Y(m-1)) + 1`
* 如果结尾字符不相等，那么问题转换成求`max(LCS(X(n-1),Y(m)),LCS(X(n),Y(m-1)))`

为了防止求重复子问题，可以使用二维矩阵state保存状态（即每个LCS），从左上角往右下角进行求解

复杂度：

* **时间复杂度**：`O(n * m)`
* **空间复杂度**：
    - 无状态压缩：`O(n * m)`
    - 状态压缩：`O(n)`或`O(m)`

> 也可以从起始字符进行分析

#### 1）无状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[0][0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int i = 1;i < len1;i++) //第一列
            state[i][0] = A[i] == B[0] ? 1 : state[i - 1][0];
        for(int j = 1;j < len2;j++) //第一行
            state[0][j] = A[0] == B[j] ? 1 : state[0][j - 1];
        for(int i = 1;i < len1;i++)
            for(int j = 1;j < len2;j++)
                state[i][j] = A[i] == B[j] ? 1 + state[i - 1][j - 1] : max(state[i - 1][j],state[i][j - 1]);
                
        return state[len1 - 1][len2 - 1];
    }
};
```

#### 2）状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<int> state(len2,0);
        state[0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int j = 1;j < len2;j++) //第一行
            state[j] = A[0] == B[j] ? 1 : state[j - 1];
        for(int i = 1;i < len1;i++){
            int tmp = state[0],tmp2;
            state[0] = A[i] == B[0] ? 1 : state[0];
            for(int j = 1;j < len2;j++){
                tmp2 = state[j];
                state[j] = A[i] == B[j] ? 1 + tmp : max(state[j],state[j - 1]);
                tmp = tmp2;
            }
        }        
        return state[len2 - 1];
    }
};
```

<br>

## 两个字符串的最长公共子串

[OJ链接](https://www.lintcode.com/problem/longest-common-substring/description)

给出2个字符串，找出它们的最长公共子串，返回其长度

例子：

* Given A = `"ABCD"`, B = `"CBCE"`, return 2

> 子串和子序列的不同在于：子串连续，子序列可以不连续

### 解答

对于字符串序列`X`和`Y`，设`state[i,j]`表示以`X[i]`和`Y[j]`开头的最长公共子串。从`X`和`Y`的起始字符分析：

* 如果起始字符相同，那么`state[0,0] = 1 + state[1,1]`
* 如果起始字符不同，那么`state[0,0] = 0`

因此，创建一个二维矩阵，可以求出所有`state[i][j]`的值，最长公共子串就是其中最大的一个

* 时间复杂度：`O(n * m)`
* 空间复杂度：`O(n * m)`

> 也可以从结尾字符开始分析；最终结果取决于每一个`state[i][j]`，所以这里不能用状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: the length of the longest common substring.
     */
    int longestCommonSubstring(string &A, string &B) {
        // write your code here
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[len1 - 1][len2 - 1] = A[len1 - 1] == B[len2 - 1] ? 1 : 0;
        //DP
        for(int i = len1 - 2;i >=0;i--) //最后一列
            state[i][len2 - 1] = A[i] == B[len2 - 1] ? 1 : 0;
        for(int j = len2 - 2;j >=0;j--) //最后一行
            state[len1 - 1][j] = A[len1 - 1] == B[j] ? 1 : 0;
        for(int i = len1 - 2;i >= 0;i--)
            for(int j = len2 - 2;j >= 0;j--)
                state[i][j] = A[i] == B[j] ? 1 + state[i + 1][j + 1] : 0;
                
        int max = 0;
        for(auto row : state)
            for(int len : row)
                if(len > max)
                    max = len;
        
        return max;
    }
};
```