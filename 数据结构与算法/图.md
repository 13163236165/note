* [图的表示](#图的表示)
    - [1.邻接矩阵](#1邻接矩阵)
    - [2.邻接表](#2邻接表)
* [图的遍历](#图的遍历)
    * [DFS(深度优先遍历)](#dfs深度优先遍历)
    * [BFS(广度优先遍历)](#bfs广度优先遍历)
    * [拓扑排序](#拓扑排序)

<br>
<br>

**图可以用G=(V,E)来表示，每个图都包括一个顶点集合V和一个边集合E，顶点总数记为|V|，边总数记为|E|**

* **稀疏图**：边数较少的图
* **密集图**：边数较多的图
* **完全图**：包含所有可能边的图
* **带权图**：边上标有权的图
* **邻接点**：一条边所连的两个顶点
* **简单路径**：路径上不包含重复顶点的图
* **回路**：将某个顶点连接到本身，且长度大于等于3的路径
* **无环图**：不带回路的图

## 图的表示

图有两种常用的表示方法：

* **邻接矩阵**
* **邻接表**

### 1.邻接矩阵

![](../pic/al-graph-1.png)

使用一个二维矩阵来表示图:

* (i,j)=1，表示顶点i到顶点j之间有一条边**（非带权图）**
* (i,j)=n，表示顶点i到顶点j之间有一条权重为n的边**（带权图）**

![](../pic/al-graph-2.png)

**使用邻接矩阵的空间代价总是O(|V|^2)**

### 2.邻接表

![](../pic/al-graph-1.png)

邻接表使用一个顶点指针数组来表示：

* 数组的元素i表示顶点i的指针，它是一个链表的头结点
* 链表其余的顶点表示与顶点i之间存在边的顶点

![](../pic/al-graph-3.png)

**邻接表的空间代价与图中边的数目和顶点的数目均有关系。每个顶点要占据一个数组元素的位置，且每条边必须出现在其中某个顶点的边链表中**

## 图的遍历

### DFS(深度优先遍历)

DFS会递归地访问它的所有未被访问的相邻顶点：

1. 先访问顶点v，把所有与v相关联的边存入栈中；
2. 弹出栈顶元素，栈顶元素代表的边所关联的另一个顶点就是要访问的下一个元素k；
3. 对k重复对v的操作；
4. 重复，直至栈中所有元素都被处理完毕

DFS的执行过程将产生一棵**DFS(深度优先搜索)树**：

![](../pic/al-graph-4.png)

整个DFS的过程如下：

![](../pic/al-graph-5.png)

> 相关题目：
> * [Leetcode：695.Max Area of Island](https://leetcode.com/problems/max-area-of-island/description/)

### BFS(广度优先遍历)

使用一个队列。对于每个顶点，在访问其它顶点前，检查当前节点所有邻接点。和树的广度优先遍历类似

BFS执行过程将产生一棵**BFS(广度优先搜索)树**：

![](../pic/al-graph-6.png)

整个BFS的过程如下：

![](../pic/al-graph-7.png)

### 拓扑排序

**(DAG)有向无环图**可以描述这样一种场景：有一组任务，任务的执行顺序之间具有依赖性，一些任务必须在另一些任务完成之后才开始执行，如下图：

![](../pic/al-graph-8.png)

在这种场景下，任务之间的依赖关系不能出现环，否则任何一个都无法开始执行。**将一个(DAG)有向无环图中所有顶点在不违反先决条件规定的基础上排成线性序列的过程就是拓扑排序**

有2种方法实现拓扑排序：

* **基于DFS的方法(递归)**：当访问某个顶点时，不对这个顶点进行任何处理。当递归返回到这个顶点时，打印这个顶点。这将产生一个逆序的拓扑排序。对齐进行一次反序操作就可以得到一个拓扑排序的序列。序列从哪个顶点开始并不重要，只要所有顶点最终都能被访问到
* **基于队列的方法(迭代)**：首先访问所有的边，计算指向每个顶点的边数(即计算每个顶点的先决条件数目)。将所有没有先决条件的顶点放入队列，然后开始处理队列。当从顶点中删除一个顶点时，把它打印出来，同时将其所有相邻顶点的先决条件计数减1。当某个相邻顶点的计数为
0时，就将其放入队列。如果还有顶点未被打印，而队列已经为空，则图中必然包含回路