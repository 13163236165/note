
## 排序算法比较

|排序|时间复杂度|空间复杂度|
|:--:|:------:|:------:|
|插入排序|O(n^2)|O(1)|
|冒泡排序|O(n^2)|O(1)|
|选择排序|O(n^2)|O(1)|

## 插入排序

逐个处理待排序的记录，每个记录与前面已排序已排序的子序列进行比较，将它插入子序列中正确位置

#### 代码

```c++
template<class Elem,class Comp>
void inssort(Elem A[],int n)
{
    for(int i = 1;i < n;i++)
        for(;int j = i;j >= 1 && (Comp::lt(A[j],A[j-1]));j--)
            swap(A,j,j-1);
}
```

#### 优化

## 冒泡排序

从数组的底部比较到顶部，比较相邻元素。如果下面的元素更小则交换，否则，上面的元素继续往上比较。这个过程每次使最小元素像个“气泡”似地被推到数组的顶部

#### 代码

```c++
template<class Elem,class Comp>
void bubsort(Elem A[],int n)
{
    for(int i = 0;i < n - 1;i++)
        for(int j = n - 1;j > i;j--)
            if(Comp::lt(A[j],A[j-1]))
                swap(A,j,j-1);
}
```

#### 优化

## 选择排序

第i次“选择”数组中第i小的记录，并将该记录放到数组的第i个位置。换句话说，每次从未排序的序列中找到最小元素，放到未排序数组的最前面

#### 代码

```c++
template<class Elem,class Comp>
void selsort(Elem A[],int n)
{
    for(int i = 0;i < n - 1;i++){
        int lowindex = i;
        for(int j = i + 1;j < n - 1;j++)
            if(Comp::lt(A[j],A[lowindex]))
                lowindex = j;
        swap(A,i,lowindex);
    }
}
```

#### 优化

