* **BST中两个鸡蛋的最低公共祖先**
* **非二叉树，节点存在指向父节点的指针**
* **非二叉树，节点不存在指向父节点的指针**

<br>
<br>

**题目一  BST中两个节点的最低公共祖先**

**解法**：从树的根节点开始和两个输入的节点进行比较。如果当前节点的值比两个节点的值都大，那么最低的共同父节点一定在当前节点的左子树中，于是下一步遍历当前节点的左子节点；如果当前节点的值比两个节点的值都小，那么最低的共同父节点一定在当前节点的右子树中，于是下一步遍历当前节点的右子节点；这样，在树中从上到下找到的第一个在两个输入节点的值之间的节点就是最低的公共祖先

<br>
<br>

**题目二  非二叉树，节点存在指向父节点的指针**

**解法**：可以转化为求两个链表的第一个公共节点的问题

<br>
<br>

**题目三  二叉树，节点存在指向父节点的指针**

[Leetcode 236](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

解法同题目四

<br>
<br>

**题目四  非二叉树，节点不存在指向父节点的指针**

**解法一(不使用辅助内存，效率低)**：从根节点开始，判断两个节点是否都在该树中，如果都在则判断两个节点是否都在根节点的子树中，如果两个节点都在以根节点的某个子节点为根节点的子树中，则继续递归判断，按这个过程一直处理，当以某个节点node为根节点的子树中包含2个节点，并且node的任一子节点都不同时包含两个节点时，这个node就是最低公共祖先

**解法二(使用辅助内存，效率高)**：用两个链表，保存从根节点到输入的两个节点的路径，然后把问题转换成求两个链表的最后最后公共节点