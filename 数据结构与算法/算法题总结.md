> 题目来源：《剑指offer》、leetcode、lintcode、hihocoder、《王道程序员求职宝典》

* **一.数组**
    - *单元素查找*
        + 《剑指offer》面试题3：[数组中重复的数字](#数组中重复的数字)
        + 《剑指offer》面试题11：[旋转数组的最小数字](#旋转数组的最小数字)（`二分查找`）
        + Leetcode33：[旋转数组中查找数字](#旋转数组中查找数字)（`二分查找` `medium`）
        + 《剑指offer》面试题53(题目一)：[有序数组中查找数字的范围](#数字在排序数组中出现的次数)（`二分查找`）
        + 《剑指offer》面试题53(题目二)：[缺失的数字](#缺失的数字)（`二分查找`）
        + 《剑指offer》面试题53(题目三)：[数组中数值和下标相等的元素](#数组中数值和下标相等的元素)（`二分查找`）
        + Leetcode162：[查找数组中任一峰值的下标](#查找数组中任一峰值的下标)（`二分查找` `medium`）
        + 《剑指offer》面试题56(题目一)：[数组中只出现1次的2个数](#数组中只出现1次的2个数)（`位运算`）
        + 《剑指offer》面试题56(题目二)：[数组中唯一只出现1次的数字](#数组中唯一只出现1次的数字)（`位运算`）
    - *范围查找*
        + 《剑指offer》面试题21：[调整数组顺序使奇数位于偶数前面](#调整数组顺序使奇数位于偶数前面)（`partition`)
        + 《剑指offer》面试题39：[数组中出现次数超过一半的数字](#数组中出现次数超过一半的数字)（`partition`）
        + 《剑指offer》面试题40：[数组中最小的k个数](#数组中最小的k个数)（`partition` `海量数据`）
    - *连续子数组*
        + 《剑指offer》面试题42：[连续子数组的最大和](#连续子数组的最大和)（`动态规划`）
        + Leetcode152：[连续子数组的最大积](#连续子数组的最大积)（`动态规划` `medium`）
    - *排列组合*
        + 《剑指offer》面试题38(相关题一)：[正方体顶点上放数字](#正方体顶点上放数字)（`全排列`）
        + 《剑指offer》面试题38(相关题二)：[八皇后](#八皇后)（`全排列`）
        + Leetcode78：[不含重复元素集合的所有子集](#不含重复元素集合的所有子集)（`组合` `medium`）
    - *排序*
        + Leetcode179：[将一组数拼接成最大数字](#将一组数拼接成最大数字)（`medium`）
    - *满足要求的元素对*
        + 《剑指offer》面试题51：[数组中的逆序对](#数组中的逆序对)（`分治归并`）
        + Leetcode315：[计算右侧小于当前元素的个数](#计算右侧小于当前元素的个数)（`分治归并` `BST` `hard`）
    - *二维数组*
        + 《剑指offer》面试题4：[二维数组中的查找](#二维数组中的查找)
        + 《剑指offer》面试题66：[构建乘积数组](#构建乘积数组)
* **二.字符串**
    - *字符串匹配*
        + Leetcode10：[正则表达式匹配](#正则表达式匹配)（`动态规划` `hard`）
        + Leetcode44：[通配符匹配](#通配符匹配)（`动态规划` `hard`）
    - *公共子串和公共子序列*
        + Lintcode77：[两个字符串的最长公共子序列](#两个字符串的最长公共子序列)（`动态规划` `medium`）
        + Lintcode79：[两个字符串的最长公共子串](#两个字符串的最长公共子串)（`动态规划` `medium`）
* **三.链表**
* **四.树**
* **五.栈和队列**
* **六.数学**
* **七.图**
* **八.海量数据**
* **九.其它**


<br>
<br>
<br>
<br>
<br>
<br>
<br>

## 数组中重复的数字

[OJ链接](https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个长度为n的数组里的所有数字都在`0~n-1`的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字

例如，如果输入长度为7的数组`{2,3,1,0,2,5,3}`，那么对应的输出是第一个重复的数字`2`

### 解答

1. **排序**（时间:O(nlogn)，空间:O(1)：先排序，然后遍历数组找到第一个重复的数字即可
2. **哈希表**（时间:O(n)，空间:O(n)）：扫描数组，使用哈希表统计每个数字出现的次数，当统计到一个以前出现过的数字时，找到重复
3. **交换**（时间:O(n)，空间:O(1)）：如果位置i的数字m不等于i，与位置m的数字比较
    - 如果位置m的数字不等于m，那么交换，直到位置i的数字等于i或位置m的数字等于m
    - 如果位置m的数字等于m，说明数字m存在重复
    ```c++
    class Solution {
    public:
        // Parameters:
        //        numbers:     an array of integers
        //        length:      the length of array numbers
        //        duplication: (Output) the duplicated number in the array number
        // Return value:       true if the input is valid, and there are some duplications in the array number
        //                     otherwise false
        bool duplicate(int numbers[], int length, int* duplication) {
            if(length <= 2)
                return false;
            for(int i = 0;i < length;i++){
                while(numbers[i] != i){
                    int m = numbers[i];
                    if(m < 0 || m >= length)
                        return false;
                    if(m == numbers[m]){
                        *duplication = m;
                        return true;
                    }
                    numbers[i] = numbers[m];
                    numbers[m] = m;
                }
            }
            return false;
        }
    };
    ```
4. **位图**：当数据量特别大时可以使用位图，相比于哈希表，更节省空间

<br>
<br>

## 旋转数组的最小数字

[OJ链接](https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素

例如数组`{3,4,5,1,2}`为`{1,2,3,4,5}`的一个旋转，该数组的最小值为`1`

NOTE：给出的所有元素都大于`0`，若数组大小为`0`，请返回`0`

### 解答

```c++
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size() == 0)
            return 0;
        if(rotateArray.size() == 1)
            return rotateArray[0];
        
        int sz = rotateArray.size();
        int l = 0,r = sz - 1;
        //如果没有旋转，不会进入循环，这样初始化会直接返回最左边元素
        int mid = l;
        while(rotateArray[r] <= rotateArray[l]){
            if(r - l == 1){
                mid = r;
                break;
            }
            mid = (l + r) >> 1;
            //如果首尾元素以及中间元素相等，那么没有办法判断中间元素到底是在左半部分还是右半部分，这时只能用顺序查找
            if(rotateArray[l] == rotateArray[r] && rotateArray[l] == rotateArray[mid]){
                int min = rotateArray[0];
                for(int i = 1;i < sz;i++){
                    if(rotateArray[i] < min) 
                        min = rotateArray[i];
                }
                return min;
            }
            if(rotateArray[mid] >= rotateArray[l])
                l = mid;
            else if(rotateArray[mid] <= rotateArray[r])
                r = mid;
        }
        return rotateArray[mid];
    }
};
```

<br>
<br>

## 旋转数组中查找数字

[OJ链接](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]`` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 O(log n) 级别。

示例 1:

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

示例 2:

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 解答

根据mid位置的值判断mid是在左半部分还是右半部分

* 如果在左半部分（说明mid位置的值比end位置的值大）
    * 当target大于mid位置的值或target小于等于end位置的值时，继续在右边查找
    * 否则，在左边查找
+ 如果在右半部分（说明mid位置的值比end位置的值小）
    * 当target大于mid位置的值并且target小于end位置的值时，才能在右边查找
    * 否则，在左边查找

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return -1;
        
        int begin = 0 , end = nums.size() - 1;
        int mid;
        while(begin <= end){
            mid = (begin + end) / 2;
            if(nums[mid] > nums[end]){//mid在左边
                if(nums[mid] == target)  return mid;
                else if(nums[mid] < target || target <= nums[end])    begin = mid + 1;
                else    end = mid - 1;
            }
            else{//mid在右边
                if(nums[mid] == target) return mid;
                else if(nums[mid] < target && target <= nums[end])  begin = mid + 1;
                else end = mid - 1;
            }
        }
        return -1;
    }
};
```

<br>
<br>

## 有序数组中查找数字的范围

[OJ链接](https://leetcode.com/problems/search-for-a-range/description/)

统计一个数字在排序数组中出现的次数

### 解答

使用二分查找，分别找到数字的下边界和上边界

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int l = searchRangel(nums,target);
        int r = searchRanger(nums,target);
        
        vector<int> v;
        v.push_back(l);
        v.push_back(r);
        return v;
    }
    
    int searchRangel(const vector<int> &nums,int target)
    {
        int l = 0,r = nums.size() - 1;
        int mid;
        
        while(l <= r){
            mid = (l + r) / 2;
            if(nums[mid] == target){
                if(mid == 0 || nums[mid - 1] != nums[mid])  return mid;
                else   r = mid - 1;
            }
            else if(nums[mid] > target) r = mid - 1;
            else    l = mid + 1;
        }
        
        return -1;
    }
    
    int searchRanger(const vector<int> &nums,int target)
    {
        int l = 0,r = nums.size() - 1;
        int mid,end = r;
        
        while(l <= r){
            mid = (l + r) / 2;
            if(nums[mid] == target){
                if(mid == end || nums[mid + 1] != nums[mid])  return mid;
                else   l = mid + 1;
            }
            else if(nums[mid] > target) r = mid - 1;
            else    l = mid + 1;
        }
        
        return -1;
    }
};
```

<br>
<br>

## 缺失的数字

一个长度为`n-1`的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围`0~n-1`之内。在范围`0~n-1`内的`n`个数字中有且只有一个数字不在该数组中，请找出这个数字

### 解答

数组中开始的一些数字与它们的下标相同，如果m不在数组中，则下标m位置的元素是m+1...问题转换为找到数组中下标和元素值不相等的第一个元素

<br>
<br>

## 数组中数值和下标相等的元素

假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编程实现一个函数找出数组中任意一个数值等于其下标的元素。例如，在数组`{-3, -1, 1, 3, 5}`中，数字3和它的下标相等

<br>
<br>

## 查找数组中任一峰值的下标

[OJ链接](https://leetcode.com/problems/find-peak-element/description/)

峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 `nums`，其中 `nums[i] ≠ nums[i+1]`，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞`。

示例 1:

```
输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
```

示例 2:

```
输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

说明:

你的解法应该是 O(logN) 时间复杂度的

### 解答

#### 1）线性查找

遍历数组，对于每个元素，如果该元素的前一元素和后一元素都小于该元素，那么该元素是一个峰值，返回

* 时间复杂度：O(n)
* 空间复杂度：O(1)

#### 2）二分查找

* 如果中间元素比右边的元素小，意味着当前处于一个“升序”中，那么右边(不含当前元素)将会出现一个峰值
* 如果中间元素比右边的元素大，意味着当前处于一个“降序”中，那么左边(包含当前元素)将会出现一个峰值
* 如果中间元素等于右边的元素，那么无法减小区间（所以题目给出了nums[i]不等于nums[i+1]）

使用上述判断一直减小区间，直到区间只有1个元素

* 时间复杂度：O(logn)
* 空间复杂度：O(1)

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int ret = -1;
        int l = 0,r = nums.size() - 1,mid;
        while(l < r){
            mid = (l + r) >> 1;
            if(nums[mid] < nums[mid + 1])
                l = mid + 1;
            else if(nums[mid] > nums[mid + 1])
                r = mid;
            //假设输入合法，如果nums[mid] == nums[mid+1]会无限循环
            //为了代码的简洁性暂时不处理这种情况
        }
        return l == r ? l : -1;
    }
};
```

<br>
<br>

## 数组中只出现1次的2个数

[OJ链接](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字

### 解答

可以先考虑如果只有1个数字出现1次，其余都2次，怎么找：

*  对所有数字异或，由于异或满足结合律交换律，结果就是所要查找的数字

对于存在2个数字出现1次的数字:

* 所有数字异或结果为这两个数字的异或值，如果能将数组分为2部分，每个数字属于其中一部分，则能求出这两个数字。可以找到这两个数字异或结果中第一个为1的位，根据该位将数组分成2个数组

```c++
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
        int num1xornum2 = 0;
        int sz = data.size();
        
        for(int i = 0;i < sz;i++)
            num1xornum2 ^= data[i];
        
        int idx = 0;
        while(((num1xornum2 & 1) == 0) && (idx < 32)){
            idx++;
            num1xornum2 = num1xornum2 >> 1;
        }
        
        *num1 = 0,*num2 = 0;
        for(int i = 0;i < sz;i++){
            if(isBit(data[i],idx))
                *num1 ^= data[i];
            else
                *num2 ^= data[i];
        } 
    }
    
    bool isBit(int num,int idx){
        while(idx){
            num = num >> 1;
            idx--;
        }
        return (num & 1);
    }
    
    bool checknum(vector<int> &data,int num1,int num2){
        int count1 = 0,count2 = 0,sz = data.size();
        for(int i = 0;i < sz;i++){
            if(data[i] == num1)
                count1++;
            if(data[i] == num2)
                count2++;
        }
        
        return (count1 == 1) && (count2 == 1);
    }
};
```

<br>
<br>

## 数组中唯一只出现1次的数字

在一个数组中除一个数字只出现一次之外，其他数字都出现了3次。请找出那个只出现一次的数字

### 解答

如果其余数字都出现2次，则使用异或很好解决，但是这里是3次，所以无法使用异或；但是还是可以沿用位运算的思路，如果一个数字出现3次，其二进制表示的每一位也出现3次，把所有出现3次的数字的二进制表示的每一位都分别加起来，每一位的和都能被3整除。我们把数组中所有数字的二进制表示的每一位都加起来。如果某一位的和能被3整除，那么只出现一次的数字二进制中对应的那一位是0，否则是1

<br>
<br>

## 调整数组顺序使奇数位于偶数前面

[OJ链接](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变

> 可以将判断元素是否满足条件的表达式设计为函数指针以满足扩展性：1）负数位于前面，正数位于后面；3）能被3整除的位于前面，不能的位于后面

### 解答

1. 基于快排的partition方法
2. 如果要求保证奇数的原有相对顺序、偶数的原有相对顺序，那么使用一个临时数组保存原数组，然后统计奇数或偶数元素的个数，使用两个指针(下标)分别指向奇数和偶数的起始位置，遍历临时数组如果是奇数则在原数组中记录并移动奇数指针，如果是偶数...

```c++
class Solution {
public:
    /*
     * 剑指offer中的题没有要求“必须保证原有顺序”
     * 如果要保证顺序，在i后面的j位置找到一个奇数时，需要把[i,...,j-1]的元素往后移动，然后把j交换到i位置，这样复杂度为O(n^2)
     * 则使用插入排序编码更简洁，如果要实现O(n)时间复杂度，必须使用一个辅助数组（空间换时间）
     * 总的来说，要求“必须保证原有顺序”比起不要求时，整个解法可以很不一样
     */
    void reOrderArray(vector<int> &array) {
        vector<int> tp = array;
        int oddcount = 0;
        for(int i : tp)
            if (i % 2 == 1)
                oddcount++;
        int m = 0,n = oddcount;
        for(int i : tp){
            if(i % 2 == 1)
                array[m++] = i;
            else
                array[n++] = i;
        }
    }
};
```

<br>
<br>

## 数组中出现次数超过一半的数字

[OJ链接](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字

例如输入一个长度为9的数组`{1,2,3,2,2,2,5,4,2}`。由于数字`2`在数组中出现了`5`次，超过数组长度的一半，因此输出`2`

如果不存在则输出`0`

### 解答

1. 基于partition的方法
2. 该数字出现的次数超过其它数字出现的次数之和（因此，考虑使用2个变量，一个保存数字，一个保存次数。当遍历到下一个数字时，如果下一数字和之前保存的数字相同，则次数加1，如果下一数字和之前保存的数字不同，则次数减1。如果次数为0，则需保存下一个数字，并把次数设为1，最后一次把次数设为1时对应的数字就是结果）​

```c++
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.size() == 0)
            return 0;
        
        int count = 0;
        int res = numbers[0];
        for(int e : numbers){
            if(e == res)
                count++;
            else{
                if(count == 0)
                    res = e;
                else
                    count--;
            }
        }
        
        count = 0;
        for(int i = 0;i < numbers.size();i++){
            if(numbers[i] == res)
                count++;
        }
        if(count * 2 <= numbers.size())
            return 0;
        return res;
    }
};
```

<br>
<br>

## 数组中最小的k个数

[OJ链接](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

输入`n`个整数，找出其中最小的`K`个数。例如输入`4,5,1,6,2,7,3,8`这8个数字，则最小的`4`个数字是`1,2,3,4`

### 解答

1. 基于partition函数的方法（不适合海量数据）
2. 使用容器(最大堆)存储最小的k个数，遍历数组，当有更小的数时替换掉原容器中最大的（适合处理海量数据，即数组不能一次载入内存）​

> 这个题改成求(从小到大)第k大的数也是这两种方法

<br>
<br>

## 连续子数组的最大和

[OJ链接](https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

### 解答

令sum[i]表示所有以位置i的元素结尾的连续子数组的最大和，状态转移方程如下：

* 当 `sum[i] <= 0` 时，`sum[i+1] = array[i + 1]`
* 当 `sum[i] > 0` 时，`sum[i+1] = sum[i] + array[i + 1]`

那么连续子数组的最大和，就是`max{sum[0],sum[1],...,sum[n-1]}`

```c++
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        if(array.size() == 0)   return 0;

        int sum = array[0],res = array[0];
        int sz = array.size();
        for(int i = 1;i < sz;i++){
            if(sum > 0)    sum += array[i];
            else           sum = array[i];
            if(sum > res)  res = sum;
        }
        
        return res;
    }
};
```

<br>
<br>

## 连续子数组的最大积

[OJ链接](https://leetcode.com/problems/maximum-product-subarray/description/)

给定一个整数数组 `nums` ，找出乘积最大的连续子数组（该数组至少包含一个数）

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是连续子数组。
```

### 解答

假设`max_local[i]`表示以`nums[i]`结尾的连续子数组的最大积，如果能求出所有`max_local`，那么最大者就是答案

现在看怎么求`max_local[i]`：

* 如果`max_local[i - 1]`为`0`
    - 当`nums[i]`大于等于`0`时，`max_local[i] = nums[i]`，与前面的子数组无关
    - 当`nums[i]`小于`0`时，`max_local[i] = 0`
* 否则，如果`nums[i]`与`max_local[i - 1]`符号相同，那么`max_local[i] = nums[i] * max_local[i - 1]`，此时将前面的连续子数组并入
* 否则，如果`nums[i]`与`max_local[i - 1]`符号不同，那么`nums[i] * max_local[i - 1]`是以`nums[i]`结尾的连续子数组的最小积，设为`min_local[i]`，如果知道`min_local[i - 1]`，那么就能求出`max_local[i]`：`max_local[i] = min_local[i - 1] * nums[i]`

因此，要求出max_local[i]，同时需要维护连续子数组的最小积——`min_local`数组，对上面的分析进行总结：因为`nums[i]`可能与`max_local[i - 1]`同号，可能异号，`max_local[i - 1]`也可能为`0`。所以`max_local[i]`取决于3个值：`max_local[i - 1]*nums[i]`、`min_local[i - 1]*nums[i]`、`nums[i]`（隐含了状态转移方程）

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.empty())    return 0;
        
        int max_global = nums[0];
        int max_local = nums[0],min_local = nums[0];
        
        for(int i = 1;i < nums.size();i++){
            int _max = max(max_local * nums[i],min_local * nums[i],nums[i]);
            int _min = min(max_local * nums[i],min_local * nums[i],nums[i]);
            max_local = _max;
            min_local = _min;
            if(max_local > max_global)  max_global = max_local;
        }
        
        return max_global;
    }
private:
    int max(int num1,int num2,int num3){
        return num1 > num2 ? (num1 > num3 ? num1 : num3) : (num2 > num3 ? num2 : num3); 
    }
    
    int min(int num1,int num2,int num3){
        return num1 < num2 ? (num1 < num3 ? num1 : num3) : (num2 < num3 ? num2 : num3);
    }
};
```

<br>
<br>

## 正方体顶点上放数字 

输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等

### 解答

相当于先得到`a1、a2、a3、a4、a5、a6、a7`和`a8`这`8`个数字的所有排列，然后判断有没有某一个排列符合题目给定的条件，即`a1+a2+a3+a4=a5+a6+a7+a8`，`a1+a3+a5+a7=a2+a4+a6+a8`，并且`a1+a2+a5+a6=a3+a4+a7+a8`

<br>
<br>

## 八皇后

在8\*8的国际象棋上摆放8个皇后，使其不能相互攻击，即任意两个皇后不得处在同一行、同一列或者同一对角线上。问总共有多少种符合条件的摆法？

### 解答

由于`8`个皇后的任意两个不能处在同一行，那么肯定是每一个皇后占据一行。于是可以定义一个数组`ColumnIndex[8]`，数组中第`i`个数字表示位于第`i`行的皇后的列号。先把数组`ColumnIndex`的`8`个数字分别用`0~7`初始化，然后对数组`ColumnIndex`进行全排列。因为用不同的数字初始化了数组，所以任意两个皇后肯定不同列。只需判断每一个排列对应的8个皇后是不是在同一条对角线上，也就是对于数组的两个下标`i`和`j`，是否有`i-j==ColumnIndex[i]-ColumnIndex[j]`或者`j-i==ColumnIndex[i]-ColumnIndex[j]`

<br>
<br>

## 不含重复元素集合的所有子集

[OJ链接](https://leetcode.com/problems/subsets/description/)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）

说明：解集不能包含重复的子集

示例:

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 解答

对于每个元素，可以选择要或者不要

* 如果要，子集等于该元素加上剩余元素的所有子集
* 如果不要，子集等于剩余元素的所有子集

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> subset;
        vector<vector<int>> res;
        subsets(nums,0,res,subset);
        return res;
    }
    
private:
    void subsets(const vector<int> &nums,int idx,vector<vector<int>> &res,vector<int> subset){
        if(idx < 0) return;
        else if(idx == nums.size()){
            res.push_back(subset);
            return;
        }
        
        subset.push_back(nums[idx]);
        subsets(nums,idx + 1,res,subset);
        subset.pop_back();
        subsets(nums,idx + 1,res,subset);
    }
};
```

<br>
<br>

## 将一组数拼接成最大数字

* 排成最大数字：[OJ链接](https://leetcode.com/problems/largest-number/description/)（Leetcode）
* 排成最小数字：[OJ链接](https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=2&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)（牛客网）

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

示例 1:

```
输入: [10,2]
输出: 210
```

示例 2:

```
输入: [3,30,34,5,9]
输出: 9534330
```

说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数

### 解答

给出数字`m`和`n`，需要确定一个规则判断`m`和`n`哪个应该排在前面，如果`mn>nm`，那么`m`应该排在`n`前面，此时定义`m>n`...

根据这个规则对数组中的数字进行排序，排序后的序列就是最大的数；

#### 1）使用函数

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),comp);
        
        //处理所有元素都是0的情况
        if(!nums.empty() && nums[0] == 0)   return "0";
        
        string res = "";
        for(int num : nums) res = res + to_string(num);
        
        return res;
    }
private:
    static bool comp(int num1,int num2){
        string s1 = to_string(num1) + to_string(num2);
        string s2 = to_string(num2) + to_string(num1);
        
        return s2 < s1;
    }
};
```

#### 2）使用lambda

```c++
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end(),[](const int &num1,const int &num2){
            return to_string(num2) + to_string(num1) < to_string(num1) + to_string(num2);
        });
        
        //处理所有元素都是0的情况
        if(!nums.empty() && nums[0] == 0)   return "0";
        
        string res = "";
        for(int num : nums) res = res + to_string(num);
        
        return res;
    }
};
```

<br>
<br>

## 数组中的逆序对

[OJ链接](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数`P`。并将`P`对`1000000007`取模的结果输出。 即输出`P%1000000007`

### 解答

1. 遍历每个元素，在这个元素的后面剩余元素中查找比该元素小的元素，每找到一个组成一个逆序对；（O(n^2)）
2. 基于归并排序的方法；（O(nlogn)）

```c++
class Solution {
public:
    int InversePairs(vector<int> data) {
       if(data.size() < 2)
           return 0;
        
        vector<int> tp = data;
        int count = 0,sz = data.size();
        InversePairs(data,tp,count,0,sz - 1);
        
        return count;
    }
    
    void InversePairs(vector<int> &data,vector<int> &tp,int &count,int l,int r){
        if(l >= r)
            return;
        
        int mid = (l + r)/2;
        InversePairs(data,tp,count,l,mid);
        InversePairs(data,tp,count,mid + 1,r);
        
        //归并
        int idx1 = mid,idx2 = r,curr = r;
        while(idx1 >= l && idx2 >= mid + 1){
            if(data[idx1] > data[idx2]){//有逆序对
                count = (idx2 - mid + count) % 1000000007;
                tp[curr--] = data[idx1--];
            }
            else{
                tp[curr--] = data[idx2--];
            }
        }
        while(idx1 >= l)
            tp[curr--] = data[idx1--];
        while(idx2 >= mid + 1)
            tp[curr--] = data[idx2--];
        
        for(int i = l;i <= r;i++)
            data[i] = tp[i];
    }
};
```

<br>
<br>

## 计算右侧小于当前元素的个数

[OJ链接](https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/)

给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。

示例:

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

### 解答

#### 1）归并(分治)

其实就是类似[求逆序对](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)的方法，不过求逆序对这个题是求出逆序对的总数即可，但是这里实际是求数组中每个元素和其后元素的数构成多少个逆序对，所以会复杂一些，但是方法一样

假设有2个数组num1（假设下标为l1-r1）和num2（假设下标为l2-r2），满足下列性质：

* num1和num2已经按照降序排好序
* l1 <= r1 < l2 <= r2

因为num1中的每个元素都在num2的前面，因此很好统计有多少个逆序对，归并过程如下：

* 对于num1中的元素m和num2中的元素n，有：
    - 如果m大于n，那么m元素的逆序对增加的数量为num2中n及n以后所有元素的数量，然后继续处理num1中m后方的元素
    - 如果m小于等于n，m及num1中m后方的元素，都不可能与n构成逆序对，因此处理num2中n后方的元素
* 上面的过程可以统计出逆序对，但是在该次归并后，下一次归并时，我们需要保证新的更大的数组依然满足降序的顺序，因此在统计逆序对的过程中需要进行归并排序
* 最后一个问题是，在统计逆序对的过程中，如果m比n大，那么需要增加m的逆序对的数量，但是在归并过程中，m的位置可能不断发生变化，同时数组中可能包含相同的值，即多个m，那么如何根据m定位到需要增加逆序对的位置？答案是使用下标，在归并和排序的过程中，使用的是一个下标数组idx，根据这个数组可以定位到元素在最初数组中的位置，同时，即使不断移动，也能索引到其值

```c++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        vector<int> idx;
        for(int i = 0;i < nums.size();i++)  idx.push_back(i);
        vector<int> res(nums.size(),0);
        vector<int> tmp(nums.size(),0);
        countSmallerCore(nums,idx,tmp,res,0,nums.size() - 1);
        return res;
    }
private:
    void countSmallerCore(vector<int> &nums,vector<int> &idx,vector<int> &tmp,vector<int> &res,int l,int r){
        if(l >= r)  return;

        int mid = (l + r) >> 1;
        countSmallerCore(nums,idx,tmp,res,l,mid);
        countSmallerCore(nums,idx,tmp,res,mid + 1,r);
        merge(nums,idx,tmp,res,l,mid,mid + 1,r);
    }

    void merge(vector<int> &nums,vector<int> &idx,vector<int> &tmp,vector<int> &res,int l1,int r1,int l2,int r2){
        int p1 = l1,p2 = l2,p = l1;
        while(p1 <= r1 && p2 <= r2){
            if(nums[idx[p1]] > nums[idx[p2]]){
                res[idx[p1]] += r2 - p2 + 1;
                tmp[p++] = idx[p1++];
            }
            else
                tmp[p++] = idx[p2++];
        }
        while(p1 <= r1) tmp[p++] = idx[p1++];
        while(p2 <= r2) tmp[p++] = idx[p2++];

        p = l1;
        while(p <= r2){
            idx[p] = tmp[p];
            p++;
        }
    }

};
```

#### 2）BST

假设从数组右边往左构建BST，每当遍历到一个元素时，其右边节点已经构成了一棵BST，对于当前节点，如果能在将其插入BST的过程中同时得到BST中小于该元素的节点个数，那么每个元素就能实现O(logn)的查找，总的时间复杂度就是O(nlogn)

为了能够在BST中快速得到比新插入元素小的节点个数，肯定需要在节点中维护除节点值以外的其它信息。因为数组中可能包含相同元素，那么BST节点中添加一个`count`变量统计相同元素的个数，那么再添加一个`left_count`变量表示BST中比当前节点值小的节点总数（**这种假设是一种全局性质**），假设这样行的通，那么只要找到新节点插入点的父节点，那么就可以根据父节点判断比新值小的元素有多少个

但是这样行不通，因为在插入节点时，需要更新BST中已有节点的`left_count`，如果`left_count`表示BST中比当前节点值小的节点总数，那么无法实现O(logn)的查找，考虑如下例子：

```
       a
      / \
     b   c 
```


* 如果新节点比a小，如果`left_count`表示BST中比当前节点值小的节点总数，那么在新节点插入时，需要递增a节点的`left_count`
* 如果新节点比a大，a节点的`left_count`不变，继续往a节点的右子树处理

注意，问题出在新节点比a小时！此时只能更新a，如果`left_count`表示BST中比当前节点值小的节点总数，那么所有a节点右子树中的节点都应该递增其`left_count`

那么到底应该赋予`left_count`什么样的意义？现在不管a节点的左子树和右子树长什么样，并且假设a是BST中任意节点。每当一个节点需要插入a节点的左边时，比a节点小的节点都加1，这是肯定没问题的。所以我们**只能保证一种局部性质**，即**`left_count`表示该节点左子树的节点总数**

那么如果`left_count`表示该节点左子树的节点总数，有没有办法在插入一个节点时获取整棵BST中比新节点小的节点总是？答案是肯定的，从根节点开始遍历，查找新节点的插入位置：

* 如果新节点大于某个节点a，那么小于新节点的节点个数就增加`a->left_count+a->count`
* 如果新节点等于某个节点a，那么小于新节点的节点个数就增加`a->left_count`
* 如果新节点小于某个节点a，此时只能知道新节点在a的左子树中，但是无法知道a的左子树中有多少节点小于新节点，所以暂时无法得出应该增加多少，因此增加`0`

```c++
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        if(nums.size() <= 0)    return vector<int>();
        
        vector<int> res;
        BSTNode *root = new BSTNode(nums.back());
        res.push_back(0);
        for(int i = nums.size() - 2;i >= 0;i--)
            res.push_back(insertBSTNode(root,nums[i]));
        
        delete root;
    
        reverse(res.begin(),res.end());
        
        return res;    
    }
private:
    struct BSTNode{
        int val;        //节点的值
        int count;      //相同值的个数
        int left_count; //左子树节点的个数
        BSTNode *left;
        BSTNode *right;
        BSTNode(int v) : val(v) , count(1) , left_count(0) , left(NULL) , right(NULL) {}
        ~BSTNode() {delete left;delete right;}
    };

    int insertBSTNode(BSTNode *root,int val){
        int res = 0;
        BSTNode *p = root,*pp;
        while(p){
            if(val < p->val){
                (p->left_count)++;
                res += 0;
                pp = p;
                p = p->left;
            }
            else if(val > p->val){
                res += p->count + p->left_count;
                pp = p;
                p = p->right;
            }
            else{
                (p->count)++;
                res += p->left_count;
                break;
            }
        }
        BSTNode *node = p;
        if(!p){ //说明不是一个以前出现过的值，因此需要插入
            node = new BSTNode(val);
            if(val < pp->val)   pp->left = node;
            else    pp->right = node;
        }
        return res;
    }
};
```

#### 3）树状数组

* [树状数组(Binary Index Tree)介绍](https://www.youtube.com/watch?v=WbafSgetDDk)
* [树状数组的解法](https://www.youtube.com/watch?v=2SVLYsq5W8M)

```c++
// Author: Huahua
// Runnning time: 32 ms
// Time complexity: O(nlogn)
// Space complexity: O(k), k is the number unique elements
class FenwickTree {    
public:
    FenwickTree(int n): sums_(n + 1, 0) {}
    
    void update(int i, int delta) {
        while (i < sums_.size()) {
            sums_[i] += delta;
            i += lowbit(i);
        }
    }
    
    int query(int i) const {        
        int sum = 0;
        while (i > 0) {
            sum += sums_[i];
            i -= lowbit(i);
        }
        return sum;
    }
private:
    static inline int lowbit(int x) { return x & (-x); }
    vector<int> sums_;
};
 
class Solution {
public:
    vector<int> countSmaller(vector<int>& nums) {
        // Sort the unique numbers
        set<int> sorted(nums.begin(), nums.end());
        // Map the number to its rank
        unordered_map<int, int> ranks;
        int rank = 0;
        for (const int num : sorted)
            ranks[num] = ++rank;
        
        vector<int> ans;
        FenwickTree tree(ranks.size());
        // Scan the numbers in reversed order
        for (int i = nums.size() - 1; i >= 0; --i) {
            // Chechk how many numbers are smaller than the current number.
            ans.push_back(tree.query(ranks[nums[i]] - 1));
            // Increse the count of the rank of current number.
            tree.update(ranks[nums[i]], 1);
        }
        
        std::reverse(ans.begin(), ans.end());
        return ans;
    }
};
```

<br>
<br>

## 二维数组中的查找

[OJ链接](https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

### 解答

选取右上角或左下角的元素，以左下角为例：

* 如果左下角元素大于查找元素，则删除所在行
* 如果左上角元素小于查找元素，则删除所在列

```c++
class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int rows = array.size();
        int columns = array[0].size();
         
        int r = rows - 1,c = 0;
        while(r >= 0 && c < columns){
            if(array[r][c] < target)
                c++;
            else if(array[r][c] > target)
                r--;
            else
                return true;
        }
         
        return false;
    }
};
```

<br>
<br>

## 构建乘积数组

[OJ链接](https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=3&rp=2&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

给定一个数组`A[0,1,...,n-1]`,请构建一个数组`B[0,1,...,n-1]`,其中`B`中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法

### 解答

可以将`B[i]`的乘积分为两部分，左边为`A[0]*A[1]*...*A[i-1]`，右边为`A[i+1]，A[i+2]...A[n-1]`

先按自上而下为每个B[i]获得左边部分的乘积，然后自下而上获得右边部分的乘积

```c++
class Solution {
public:
    vector<int> multiply(const vector<int>& A) {
        vector<int> B;
        if(A.size() < 2)
            return B;
        
        int value = 1;
        B.push_back(1);
        for(int i = 1;i < A.size();i++){
            B.push_back(B.back() * A[i - 1]);
        }
        
        int tp = 1;
        for(int j = A.size() - 2;j >= 0;j--){
            tp = tp * A[j+1];
            B[j] *= tp;
        }
        
        return B;
    }
};
```

<br>
<br>

## 正则表达式匹配

[OJ链接](#https://leetcode.com/problems/regular-expression-matching/description/)

给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
```

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

示例 3:

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

示例 4:

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

示例 5:

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 解答

**动态规划**

创建一个二维矩阵记录状态。`state[i][j]`表示`s[0~i-1]`能否和`p[0~j-1]`匹配：

* 如果`p[j - 1] == '*'`，此时`p[j - 2]`可以使用也可以不使用
    - 如果使用，`state[i][j] = ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j])`
    - 如果不使用，`state[i][j] = state[i][j - 2]`
* 如果`p[j - 1] == '.'`，此时`state[i][j] = state[i - 1][j - 1]`
* 否则，`state[i][j] = p[j - 1] == s[i - 1] && state[i - 1][j - 1]`

**注意二维bool矩阵的创建方法，这里不要使用vector**

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        bool **state = new bool*[len1 + 1];
        for(int i = 0;i <= len1;i++)
            state[i] = new bool[len2 + 1];
        
        //第一列，p = ""
        state[0][0] = true;
        for(int i = 1;i <= len1;i++)    state[i][0] = false;
        
        //第一行，s = ""
        state[0][1] = false;
        for(int j = 2;j <= len2;j++)    state[0][j] = (p[j - 1] == '*') ? (state[0][j - 2]) : false;
        
        for(int i = 1;i <= len1;i++)
            for(int j = 1;j <= len2;j++){
                if(p[j - 1] == '*')
                    state[i][j] = state[i][j - 2] || ((p[j - 2] == '.' || p[j - 2] == s[i - 1]) && state[i - 1][j]);
                else if(p[j - 1] == '.')
                    state[i][j] = state[i - 1][j - 1];
                else
                    state[i][j] = (p[j - 1] == s[i - 1]) && state[i - 1][j - 1];
            }
        
        return state[len1][len2];
    }
};
```

<br>
<br>

## 通配符匹配

[OJ链接](#https://leetcode.com/problems/wildcard-matching/description/)

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
```

两个字符串完全匹配才算匹配成功。

说明:

* s 可能为空，且只包含从 a-z 的小写字母。
* p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```

示例 3:

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```

示例 4:

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

示例 5:

```
输入:
s = "acdcb"
p = "a*c?b"
输入: false
```

### 解答

使用动态规划

给出字符串s，和字符串模板p。假设matches\[0\]\[0\]表示s和p是否能匹配。可以根据p[0]进行分析：

* 如果p[0]==‘\*’，那么可以选择\*匹配一个字符，或者不匹配。如果匹配一个字符，那么matches\[0\]\[0\]取决于s.substr[1]与p是否匹配；如果\*不匹配一个字符，那么matches\[0\]\[0\]取决于s与p.substr[1]是否匹配。即matches\[0\]\[0\] = matches\[1\]\[0\] || matches\[0\]\[1\]
* 如果p[0]=='?'，那么必须匹配一个字符，因此matches\[0\]\[0\] = matches\[1\]\[1\]
* 否则，matches\[0\]\[0\] = s\[0\] == p\[0\] && matches\[1\]\[1\]

因此可以根据上面3种情况得到状态转移方程

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = s.length(),len2 = p.length();
        
        vector<vector<char>> matches(len1 + 1,vector<char>(len2 + 1));
        for(int i = 0;i < len1;i++)  // p == ""
            matches[i][len2] = 0;
        matches[len1][len2] = 1;       // p == "" && s == ""
        for(int j = len2 - 1;j >= 0;j--) // s == ""
            matches[len1][j] = (p[j] == '*' && matches[len1][j + 1]);
        
        for(int i = len1 - 1;i >= 0;i--){ // s.substr[i] match p.substr[j] ?
            for(int j = len2 - 1;j >= 0;j--){
                if(p[j] == '?')
                    matches[i][j] = matches[i + 1][j + 1];
                else if(p[j] == '*')
                    matches[i][j] = matches[i + 1][j] || matches[i][j + 1];
                else
                    matches[i][j] = (s[i] == p[j] && matches[i + 1][j + 1]);
            }
        }
        
        return matches[0][0];
    }
};
```

<br>
<br>

## 两个字符串的最长公共子序列

[OJ链接](https://www.lintcode.com/problem/longest-common-subsequence/description)

给出2个字符串，找出它们的最长公共子序列（LCS）。返回其长度

例子：

* For `"ABCD"` and `"EDCA"`, the LCS is `"A"` (or `"D"`, `"C"`), return `1`.
* For `"ABCD"` and `"EACB"`, the LCS is `"AC"`, return `2`.

### 解答

假设两个字符串序列为X和Y，从结尾字符进行分析（设`n`和`m`为两个字符串的长度）：

* 如果结尾字符相等，那么问题转换为求序列`X(n-1)`和`Y(m-1)`的最长公共子序列，即：`LCS(X(n-1),Y(m-1)) + 1`
* 如果结尾字符不相等，那么问题转换成求`max(LCS(X(n-1),Y(m)),LCS(X(n),Y(m-1)))`

为了防止求重复子问题，可以使用二维矩阵state保存状态（即每个LCS），从左上角往右下角进行求解

复杂度：

* **时间复杂度**：`O(n * m)`
* **空间复杂度**：
    - 无状态压缩：`O(n * m)`
    - 状态压缩：`O(n)`或`O(m)`

> 也可以从起始字符进行分析

#### 1）无状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[0][0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int i = 1;i < len1;i++) //第一列
            state[i][0] = A[i] == B[0] ? 1 : state[i - 1][0];
        for(int j = 1;j < len2;j++) //第一行
            state[0][j] = A[0] == B[j] ? 1 : state[0][j - 1];
        for(int i = 1;i < len1;i++)
            for(int j = 1;j < len2;j++)
                state[i][j] = A[i] == B[j] ? 1 + state[i - 1][j - 1] : max(state[i - 1][j],state[i][j - 1]);
                
        return state[len1 - 1][len2 - 1];
    }
};
```

#### 2）状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: The length of longest common subsequence of A and B
     */
    int longestCommonSubsequence(string &A, string &B) {
        // write your code 
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<int> state(len2,0);
        state[0] = A[0] == B[0] ? 1 : 0;
        //DP
        for(int j = 1;j < len2;j++) //第一行
            state[j] = A[0] == B[j] ? 1 : state[j - 1];
        for(int i = 1;i < len1;i++){
            int tmp = state[0],tmp2;
            state[0] = A[i] == B[0] ? 1 : state[0];
            for(int j = 1;j < len2;j++){
                tmp2 = state[j];
                state[j] = A[i] == B[j] ? 1 + tmp : max(state[j],state[j - 1]);
                tmp = tmp2;
            }
        }        
        return state[len2 - 1];
    }
};
```

<br>
<br>

## 两个字符串的最长公共子串

[OJ链接](https://www.lintcode.com/problem/longest-common-substring/description)

给出2个字符串，找出它们的最长公共子串，返回其长度

例子：

* Given A = `"ABCD"`, B = `"CBCE"`, return 2

> 子串和子序列的不同在于：子串连续，子序列可以不连续

### 解答

对于字符串序列`X`和`Y`，设`state[i,j]`表示以`X[i]`和`Y[j]`开头的最长公共子串。从`X`和`Y`的起始字符分析：

* 如果起始字符相同，那么`state[0,0] = 1 + state[1,1]`
* 如果起始字符不同，那么`state[0,0] = 0`

因此，创建一个二维矩阵，可以求出所有`state[i][j]`的值，最长公共子串就是其中最大的一个

* 时间复杂度：`O(n * m)`
* 空间复杂度：`O(n * m)`

> 也可以从结尾字符开始分析；最终结果取决于每一个`state[i][j]`，所以这里不能用状态压缩

```c++
class Solution {
public:
    /**
     * @param A: A string
     * @param B: A string
     * @return: the length of the longest common substring.
     */
    int longestCommonSubstring(string &A, string &B) {
        // write your code here
        if(A == "" || B == "")  return 0;
        int len1 = A.length();
        int len2 = B.length();
        vector<vector<int> > state(len1,vector<int>(len2,0));
        state[len1 - 1][len2 - 1] = A[len1 - 1] == B[len2 - 1] ? 1 : 0;
        //DP
        for(int i = len1 - 2;i >=0;i--) //最后一列
            state[i][len2 - 1] = A[i] == B[len2 - 1] ? 1 : 0;
        for(int j = len2 - 2;j >=0;j--) //最后一行
            state[len1 - 1][j] = A[len1 - 1] == B[j] ? 1 : 0;
        for(int i = len1 - 2;i >= 0;i--)
            for(int j = len2 - 2;j >= 0;j--)
                state[i][j] = A[i] == B[j] ? 1 + state[i + 1][j + 1] : 0;
                
        int max = 0;
        for(auto row : state)
            for(int len : row)
                if(len > max)
                    max = len;
        
        return max;
    }
};
```