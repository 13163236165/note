* [一.文件I/O](#一文件IO)
    - [1.文件描述符](#1文件描述符)
    - [2.相关调用](#2相关调用)
        + [2.1 打开文件](#21-打开文件)
        + [2.2 创建文件](#22-创建文件)
        + [2.3 关闭文件](#23-关闭文件)
        + [2.4 定位读写位置](#24-定位读写位置)
        + [2.5 文件读](#25-文件读)
        + [2.6 文件写](#26-文件写)

<br>
<br>

<div align="center"> <img src="../pic/apue-basic-1.png"/> </div>

<br>
<br>
<br>

# 一.文件I/O
  
本章描述的函数经常被称为**不带缓冲的I/O**，不带缓冲值的是每个read和write都调用内核中的一个系统调用。这些不带缓冲的I/O函数不是ISO C的组成部分，它们是POSIX.1和Single UNIX Specification的组成部分

## 1.文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负数。范围是0~OPEN_MAX-1。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：

* 0： 标准输入
* 1： 标准输出
* 2： 标准错误输出

通常使用STDIN_FILENO，STDOUT_FILENO和 STDERR_FILENO来替代这三个幻数，从而提高可读性。这三个常量位于\<unistd.h\>中

<br>

## 2.相关调用

### 2.1 打开文件

<div align="center"> <img src="../pic/apue-fileio-1.png"/> </div>

* 参数：
    * `path`:要打开或者创建文件的名字
    * `oflag`：用于指定函数的操作行为：
        * `O_RDONLY`常量：文件只读打开
        * `O_WRONLY`常量：文件只写打开
        * `O_RDWR`常量：文件读、写打开
        * `O_EXEC`常量：只执行打开
        * `O_SEARCH`常量：只搜索打开（应用于目录）。本书涉及的操作系统都没有支持该常量

        **以上五个常量必须且只能指定一个。下面的常量是可选的（进行或运算）**：
        * `O_APPEND`：每次写时都追加到文件的尾端
        * `O_CLOEXEC`：将`FD_CLOEXEC`常量设置为文件描述符标志
        * `O_CREAT`：若文件不存在则创建。使用此选项时，需要同时说明参数`mode`（指定该文件的访问权限）
        * `O_DIRECTORY`：若`path`引用的不是目录，则出错
        * `O_EXCL`：若同时指定了`O_CREAT`时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作
        * `O_NOCTTY`：若`path`引用的是终端设备，则不将该设备分配作为此进程的控制终端
        * `O_NOFOLLOW`：若`path`引用的是一个符号链接，则出错
        * `O_NONBLOCK`：如果`path`引用的是一个`FIFO`、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式。
        * `O_SYNC`：每次 `write` 等待物理 I/O 完成，包括由 `write` 操作引起的文件属性更新所需的 I/O 
        * `O_TRUNC`： 如果此文件存在，且为`O_WRONLY`或者`O_RDWR`成功打开，则将其长度截断为0
        * `O_RSYNC`：使每一个`read`操作等待，直到所有对文件同一部分挂起的写操作都完成。
        * `O_DSYNC`：每次 `write` 等待物理 I/O 完成，但不包括由 `write` 操作引起的文件属性更新所需的 I/O 

    *  `mode`：文件访问权限。文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
        * `S_IRUSR`：用户读
        * `S_IWUSR`：用户写
        * `S_IXUSR`：用户执行
        * `S_IRGRP`：组读
        * `S_IWGRP`：组写          
        * `S_IXGRP`：组执行         
        * `S_IROTH`：其他读
        * `S_IWOTH`：其他写
        * `S_IXOTH`：其他执行 

对于`openat`函数，被打开的文件名由`fd`和`path`共同决定：
    * 如果`path`指定的是绝对路径，此时`fd`被忽略。`openat`等价于`open`
    * 如果`path`指定的是相对路径名，则`fd`是一个目录的文件描述符。被打开的文件的绝对路径由该`fd`描述符对应的目录加上`path`组合而成
    * 如果`path`是一个相对路径名，而`fd`是常量`AT_FDCWD`，则`path`相对于当前工作目录。被打开文件在当前工作目录中查找。

由 `open/openat` 返回的文件描述符一定是**最小的未使用**的描述符数字

### 2.2 创建文件

<div align="center"> <img src="../pic/apue-fileio-2.png"/> </div>

* 参数：
    * `path`:要创建文件的名字
    * `mode`：指定该文件的访问权限。文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
        * `S_IRUSR`：用户读
        * `S_IWUSR`：用户写
        * `S_IXUSR`：用户执行
        * `S_IRGRP`：组读
        * `S_IWGRP`：组写          
        * `S_IXGRP`：组执行         
        * `S_IROTH`：其他读
        * `S_IWOTH`：其他写
        * `S_IXOTH`：其他执行

该函数等价于`open(path,O_WRONLY|O_CREAT|O_TRUNC,mode)`

`creat`的存在一个不足是：**它以只写方式打开创建的文件**。如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用`create`、`close`，然后再调用`open`，新版本`open`出来后，可以以下列方式实现：

`open(path,O_RDWR|O_CREAT|O_TRUNC,mode)`

### 2.3 关闭文件

<div align="center"> <img src="../pic/apue-fileio-3.png"/> </div>

注意：
    - 进程关闭一个文件会释放它加在该文件上的所有记录锁
    - 当一个进程终止时，内核会自动关闭它所有的打开的文件

### 2.4 定位读写位置

<div align="center"> <img src="../pic/apue-fileio-4.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `whence`：必须是 `SEEK_SET`、`SEEK_CUR`、`SEEK_END`三个常量之一
    * `offset`：
        * 如果 `whence`是`SEEK_SET`，则将该文件的偏移量设置为距离文件开始处`offset`个字节
        * 如果 `whence` 是 `SEEK_CUR`，则将该文件的偏移量设置为当前值加上`offset`个字节，`offset`可正，可负
        * 如果 `whence` 是 `SEEK_END`，则将该文件的偏移量设置为文件长度加上`offset`个字节，`offset`可正，可负

每个打开的文件都有一个与其关联的“当前文件偏移量”。它通常是个非负整数，用于度量从文件开始处计算的字节数。通常读、写操作都从当前文件偏移量处开始，并且使偏移量增加所读写的字节数。注意：
    - 打开一个文件时，除非指定`O_APPEND`选项，否则系统默认将该偏移量设为0
    - 如果文件描述符指定的是一个管道、FIFO、或者网络套接字，则无法设定当前文件偏移量，则`lseek`将返回 -1 ，并且将 `errno` 设置为 `ESPIPE`
    - 对于普通文件，其当前文件偏移量必须是非负值。但是某些设备运行负的偏移量出现。因此比较`lseek`的结果时，不能根据它小于0 就认为出错。要根据是否等于 -1 来判断是否出错
    - **`lseek` 并不会引起任何 I/O 操作，`lseek`仅仅将当前文件的偏移量记录在内核中**
    - **当前文件偏移量可以大于文件的当前长度。此时对该文件的下一次写操作将家常该文件，并且在文件中构成一个空洞。空洞中的内容位于文件中但是没有被写过，其字节被读取时都被读为0（文件中的空洞并不要求在磁盘上占据存储区。具体处理方式与操作系统有关）**

### 2.5 文件读

<div align="center"> <img src="../pic/apue-fileio-5.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `buf`：存放读取内容的缓冲区的地址（由程序员手动分配）
    * `nbytes`：期望读到的字节数

读操作从文件的当前偏移量开始，在成功返回之前，文件的当前偏移量会增加实际读到的字节数

有多种情况可能导致实际读到的字节数少于期望读到的字节数：
    - 读普通文件时，在读到期望字节数之前到达了文件尾端
    - 当从终端设备读时，通常一次最多读取一行（终端默认是行缓冲的）
    - 当从网络读时，网络中的缓存机制可能造成返回值小于期望读到的字节数
    - 当从管道或者`FIFO`读时，若管道包含的字节少于所需的数量，则 `read`只返回实际可用的字节数
    - 当从某些面向记录的设备（如磁带）中读取时，一次最多返回一条记录
    - 当一个信号造成中断，而已读了部分数据时

### 2.6 文件写

<div align="center"> <img src="../pic/apue-fileio-6.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `buf`：存放待写的数据内容的缓冲区的地址（由程序员手动分配）
    * `nbytes`：期望写入文件的字节数

`write`的返回值通常都是与`nbytes`相同。否则表示出错（出错的一个常见原因是磁盘写满，或者超过了一个给定进行的文件长度限制）

对于普通文件，写操作从文件的当前偏移量处开始。如果打开文件时指定了`O_APPEND`选项，则每次写操作之前，都会将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数

<br>

# 二.文件和目录

# 三.标准I/O库

# 四.进程环境

# 五.进程控制

# 六.进程关系

# 七.信号

# 八.线程

# 九.线程控制

# 十.进程间通信