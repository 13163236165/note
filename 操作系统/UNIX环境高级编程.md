* [一.文件I/O](#一文件io)
    - [1.文件描述符](#1文件描述符)
    - [2.相关调用](#2相关调用)
        + [2.1 打开文件](#21-打开文件)
        + [2.2 创建文件](#22-创建文件)
        + [2.3 关闭文件](#23-关闭文件)
        + [2.4 定位读写位置](#24-定位读写位置)
        + [2.5 文件读](#25-文件读)
        + [2.6 文件写](#26-文件写)
        + [2.7 fcntl函数](#27-fcntl函数)
    - [3.进程间文件共享](#3进程间文件共享)
    - [4.原子操作](#4原子操作)
    - [5.数据同步](#5数据同步)
* [三.标准I/O库](#三标准io库)
    - [1.流](#1流)
        + [1.1 流的定向](#11-流的定向)
        + [1.2 3个标准流](#12-3个标准流)
    - [2.FILE对象](#2file对象)
    - [3.缓冲](#3缓冲)
        + [3.1 3种缓冲类型](#31-3种缓冲类型)
        + [3.2 缓冲区冲洗](#32-缓冲区冲洗)
        + [3.3 标准流与缓冲](#33-标准流与缓冲)
    - [4.相关调用](#4相关调用)
        + [4.1 打开流](#41-打开流)
        + [4.2 关闭流](#42-关闭流)

<br>
<br>

<div align="center"> <img src="../pic/apue-basic-1.png"/> </div>

<br>
<br>
<br>

# 一.文件I/O
  
本章描述的函数经常被称为**不带缓冲的I/O**，不带缓冲值的是每个read和write都调用内核中的一个系统调用。这些不带缓冲的I/O函数不是ISO C的组成部分，它们是POSIX.1和Single UNIX Specification的组成部分

## 1.文件描述符

对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负数。范围是0~OPEN_MAX-1。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：

* 0： 标准输入
* 1： 标准输出
* 2： 标准错误输出

通常使用`STDIN_FILENO`，`STDOUT_FILENO`和 `STDERR_FILENO`来替代这三个幻数，从而提高可读性。这三个常量位于`<unistd.h>`中

### 复制文件描述符

<div align="center"> <img src="../pic/apue-fileio-10.png"/> </div>

* 对于`dup`函数
    - 返回的新的文件描述符一定是当前可用的文件描述符中最小的数字
* 对于`dup2`函数：
    - 如果 `fd2`已经是被打开的文件描述符且不等于`fd`，则先将其关闭，然后再打开（<font color='red'>注意关闭再打开是一个原子操作</font>）
    - 如果 `fd2`等于`fd`，则直接返回`fd2`（也等于`fd`），而不作任何操作

这些函数返回的新文件描述符与参数fd共享同一个文件表项：

<div align="center"> <img src="../pic/apue-fileio-11.png"/> </div>

<br>

## 2.相关调用

### 2.1 打开文件

<div align="center"> <img src="../pic/apue-fileio-1.png"/> </div>

* 参数：
    * `path`:要打开或者创建文件的名字
    * `oflag`：用于指定函数的操作行为：
        * `O_RDONLY`常量：文件只读打开
        * `O_WRONLY`常量：文件只写打开
        * `O_RDWR`常量：文件读、写打开
        * `O_EXEC`常量：只执行打开
        * `O_SEARCH`常量：只搜索打开（应用于目录）。本书涉及的操作系统都没有支持该常量

        **以上五个常量必须且只能指定一个。下面的常量是可选的（进行或运算）**：
        * `O_APPEND`：每次写时都追加到文件的尾端
        * `O_CLOEXEC`：将`FD_CLOEXEC`常量设置为文件描述符标志
        * `O_CREAT`：若文件不存在则创建。使用此选项时，需要同时说明参数`mode`（指定该文件的访问权限）
        * `O_DIRECTORY`：若`path`引用的不是目录，则出错
        * `O_EXCL`：若同时指定了`O_CREAT`时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作
        * `O_NOCTTY`：若`path`引用的是终端设备，则不将该设备分配作为此进程的控制终端
        * `O_NOFOLLOW`：若`path`引用的是一个符号链接，则出错
        * `O_NONBLOCK`：如果`path`引用的是一个`FIFO`、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式
        * `O_SYNC`：每次 `write` 等待物理 I/O 完成，包括由 `write` 操作引起的文件属性更新所需的 I/O 
        * `O_TRUNC`： 如果此文件存在，且为`O_WRONLY`或者`O_RDWR`成功打开，则将其长度截断为0
        * `O_RSYNC`：使每一个`read`操作等待，直到所有对文件同一部分挂起的写操作都完成
        * `O_DSYNC`：每次 `write` 等待物理 I/O 完成，但不包括由 `write` 操作引起的文件属性更新所需的 I/O 

    *  `mode`：文件访问权限。文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
        * `S_IRUSR`：用户读
        * `S_IWUSR`：用户写
        * `S_IXUSR`：用户执行
        * `S_IRGRP`：组读
        * `S_IWGRP`：组写          
        * `S_IXGRP`：组执行         
        * `S_IROTH`：其他读
        * `S_IWOTH`：其他写
        * `S_IXOTH`：其他执行 

对于`openat`函数，被打开的文件名由`fd`和`path`共同决定：

* 如果`path`指定的是绝对路径，此时`fd`被忽略。`openat`等价于`open`
* 如果`path`指定的是相对路径名，则`fd`是一个目录的文件描述符。被打开的文件的绝对路径由该`fd`描述符对应的目录加上`path`组合而成
* 如果`path`是一个相对路径名，而`fd`是常量`AT_FDCWD`，则`path`相对于当前工作目录。被打开文件在当前工作目录中查找。

由 `open/openat` 返回的文件描述符一定是**最小的未使用**的描述符数字

### 2.2 创建文件

<div align="center"> <img src="../pic/apue-fileio-2.png"/> </div>

* 参数：
    * `path`:要创建文件的名字
    * `mode`：指定该文件的访问权限。文件访问权限常量在 `<sys/stat.h>` 中定义，有下列九个：
        * `S_IRUSR`：用户读
        * `S_IWUSR`：用户写
        * `S_IXUSR`：用户执行
        * `S_IRGRP`：组读
        * `S_IWGRP`：组写          
        * `S_IXGRP`：组执行         
        * `S_IROTH`：其他读
        * `S_IWOTH`：其他写
        * `S_IXOTH`：其他执行

该函数等价于`open(path,O_WRONLY|O_CREAT|O_TRUNC,mode)`

`creat`的存在一个不足是：**它以只写方式打开创建的文件**。如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用`create`、`close`，然后再调用`open`，新版本`open`出来后，可以以下列方式实现：

`open(path,O_RDWR|O_CREAT|O_TRUNC,mode)`

### 2.3 关闭文件

<div align="center"> <img src="../pic/apue-fileio-3.png"/> </div>

注意：

- 进程关闭一个文件会释放它加在该文件上的所有记录锁
- 当一个进程终止时，内核会自动关闭它所有的打开的文件

### 2.4 定位读写位置

<div align="center"> <img src="../pic/apue-fileio-4.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `whence`：必须是 `SEEK_SET`、`SEEK_CUR`、`SEEK_END`三个常量之一
    * `offset`：
        * 如果 `whence`是`SEEK_SET`，则将该文件的偏移量设置为距离文件开始处`offset`个字节
        * 如果 `whence` 是 `SEEK_CUR`，则将该文件的偏移量设置为当前值加上`offset`个字节，`offset`可正，可负
        * 如果 `whence` 是 `SEEK_END`，则将该文件的偏移量设置为文件长度加上`offset`个字节，`offset`可正，可负

每个打开的文件都有一个与其关联的“当前文件偏移量”。它通常是个非负整数，用于度量从文件开始处计算的字节数。通常读、写操作都从当前文件偏移量处开始，并且使偏移量增加所读写的字节数。注意：

- 打开一个文件时，除非指定`O_APPEND`选项，否则系统默认将该偏移量设为0
- 如果文件描述符指定的是一个管道、FIFO、或者网络套接字，则无法设定当前文件偏移量，则`lseek`将返回 -1 ，并且将 `errno` 设置为 `ESPIPE`
- 对于普通文件，其当前文件偏移量必须是非负值。但是某些设备运行负的偏移量出现。因此比较`lseek`的结果时，不能根据它小于0 就认为出错。要根据是否等于 -1 来判断是否出错
- **`lseek` 并不会引起任何 I/O 操作，`lseek`仅仅将当前文件的偏移量记录在内核中**
- **当前文件偏移量可以大于文件的当前长度。此时对该文件的下一次写操作将家常该文件，并且在文件中构成一个空洞。空洞中的内容位于文件中但是没有被写过，其字节被读取时都被读为0（文件中的空洞并不要求在磁盘上占据存储区。具体处理方式与操作系统有关）**

### 2.5 文件读

<div align="center"> <img src="../pic/apue-fileio-5.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `buf`：存放读取内容的缓冲区的地址（由程序员手动分配）
    * `nbytes`：期望读到的字节数

读操作从文件的当前偏移量开始，在成功返回之前，文件的当前偏移量会增加实际读到的字节数

有多种情况可能导致实际读到的字节数少于期望读到的字节数：

- 读普通文件时，在读到期望字节数之前到达了文件尾端
- 当从终端设备读时，通常一次最多读取一行（终端默认是行缓冲的）
- 当从网络读时，网络中的缓存机制可能造成返回值小于期望读到的字节数
- 当从管道或者`FIFO`读时，若管道包含的字节少于所需的数量，则 `read`只返回实际可用的字节数
- 当从某些面向记录的设备（如磁带）中读取时，一次最多返回一条记录
- 当一个信号造成中断，而已读了部分数据时

### 2.6 文件写

<div align="center"> <img src="../pic/apue-fileio-6.png"/> </div>

* 参数：
    * `fd`：打开的文件的文件描述符
    * `buf`：存放待写的数据内容的缓冲区的地址（由程序员手动分配）
    * `nbytes`：期望写入文件的字节数

`write`的返回值通常都是与`nbytes`相同。否则表示出错（出错的一个常见原因是磁盘写满，或者超过了一个给定进行的文件长度限制）

对于普通文件，写操作从文件的当前偏移量处开始。如果打开文件时指定了`O_APPEND`选项，则每次写操作之前，都会将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数

### 2.7 fcntl函数

fcntl可以改变已经打开文件的属性

<div align="center"> <img src="../pic/apue-fileio-13.png"/> </div>

* 参数：
    * `fd`：已打开文件的描述符
    * `cmd`：有下列若干种：
        - **复制一个已有的描述符**（还可以使用`dup`或`dup2`）
            - `F_DUPFD`：复制文件描述符 `fd`。新文件描述符作为函数值返回。它是尚未打开的文件描述符中大于或等于`arg`中的最小值。新文件描述符与`fd`共享同一个文件表项，但是新描述符有自己的一套文件描述符标志，其中`FD_CLOEXEC`文件描述符标志被清除
            - `F_DUPFD_CLOEXEC`：复制文件描述符。新文件描述符作为函数值返回。它是尚未打开的个描述符中大于或等于`arg`中的最小值。新文件描述符与`fd`共享同一个文件表项，但是新描述符有自己的一套文件描述符标志，其中`FD_CLOEXEC`文件描述符标志被设置
        * **获取/设置文件描述符标志**
            - `F_GETFD`：对应于`fd`的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志`FD_CLOEXEC`
            - `F_SETFD`：设置`fd`的文件描述符标志为`arg`
        * **获取/设置文件状态标志**
            - `F_GETFL`：返回`fd`的文件状态标志。获得文件状态标志后，必须首先用屏蔽字 `O_ACCMODE` 取得访问方式位，然后与`O_RDONLY`、`O_WRONLY`、`O_RDWR`、`O_EXEC`、`O_SEARCH`比较（这5个值互斥，且并不是各占1位）。剩下的还有：`O_APPEND`、`O_NONBLOCK`、`O_SYNC`
        、`O_DSYNC`、`O_RSYNC`、`F_ASYNC`、`O_ASYNC`
            - `F_SETFL`：设置`fd`的文件状态标志为 `arg`。可以更改的标志是：
      `O_APPEND`、`O_NONBLOCK`、`O_SYNC`、`O_DSYNC`、`O_RSYNC`、`F_ASYNC`、`O_ASYNC`
        * **获取/设置异步I/O所有权**
            - `F_GETOWN`：获取当前接收 `SIGIO`和`SIGURG`信号的进程 `ID`或者进程组 `ID`
            - `F_SETOWN`：设置当前接收 `SIGIO`和`SIGURG`信号的进程 `ID`或者进程组 `ID`为`arg`。若 `arg`是个正值，则设定进程 `ID`；若 `arg`是个负值，则设定进程组`ID`
        * **获取/设置记录锁**
            - `F_GETLK`、`F_SETLK`、`F_SETLKW`
    * `arg`：依赖于具体的命令 

<br>

## 3.进程间文件共享

UNIX系统支持在不同进程间共享打开文件。内核使用3种数据结构描述打开文件。它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响

* 内核为每个进程分配一个**进程表项**（所有进程表项构成进程表），进程表中都有一个打开的文件描述符表。每个文件描述符占用一项，其内容为：
    * 文件描述符标志
    * 指向一个文件表项的指针
* 内核为每个打开的文件分配一个**文件表项**（所有的文件表项构成文件表）。每个文件表项的内容包括：
    * 文件状态标志（读、写、添写、同步和阻塞等）
    * 当前文件偏移量
    * 指向该文件 v 结点表项的指针
* 每个打开的文件或者设备都有一个 **v 结点结构**。 v 结点结构的内容包括： 
    * 文件类型和对此文件进行各种操作函数的指针
    * 对于大多数文件， v 结点还包含了该文件的 i 结点
    **这些信息都是在打开文件时从磁盘读入内存的**。如 i 结点包含了文件的所有者、文件长度、指向文件实际数据在磁盘上所在位置的指针等等。 v 结点结构和 i 结点结构实际上代表了文件的实体（**Linux没有使用v节点，而是使用了通用i节点结构。虽然两种实现有所不同，但在概念上，v节点与i节点是一样的，两者都指向文件系统特有的i节点结构**）

<div align="center"> <img src="../pic/apue-fileio-7.png"/> </div>

现在假设进程 A 打开文件 `file1`，返回文件描述符 3；进程 B 也打开文件 `file2`，返回文件描述符 4：

<div align="center"> <img src="../pic/apue-fileio-8.png"/> </div>

内核在文件表上新增两个表项：

- 这两个文件表项指向同一个 v 结点表项
- 进程 A 、B 各自的文件描述符表项分别指向这两个文件表项（因此每个进程都有自己的对该文件的当前偏移）

对文件的操作结果：

- 每次 `write` 之后，在文件表项中的当前文件偏移量即增加所写入的字节数
    - 若这导致当前文件偏移量超过当前文件长度，则修改 i 节点的当前文件长度，设为当前文件偏移量
- 如果用 `O_APPEND` 标志打开一个文件，则相应标志也设置到文件表项的文件状态标志中
    - 每次对具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先被置为 i 结点中的文件长度
- 若用 `lseek` 定位到文件当前的尾端，则文件表项中的当前文件偏移量设置为 i 结点中的文件长度
    - `lseek` 函数只是修改文件表项中的当前文件偏移量，不进行任何 I/O 操作

<br>

## 4.原子操作

> 多个进程写同一文件时，可能产生预想不到的结果。为了避免这种情况，需要理解原子操作

多个进程同时追加写一个文件时，如果通过 `lseek` 到末尾然后 `write` 可能出现问题：因为 “先定位到文件尾端，然后写” 并不是一个原子操作，如果先执行两个进程的 `lseek` ，然后执行 `write` ，就会出现问题

UNIX提供了一种原子操作方法：通过 `O_APPEND`选项打开文件。这样做使得内核在每次调用 `write` 执行写操作之前，都将进程的当前偏移量设置到该文件的末尾，于是就不需要执行`lseek`定位操作

### 定位读和定位写

<div align="center"> <img src="../pic/apue-fileio-9.png"/> </div>

* 参数：
    * `fd`：打开的文件描述符
    * `buf`：读出数据存放的缓冲区/ 写到文件的数据的缓冲区
    * `nbytes`：预期读出/写入文件的字节数
    * `offset`：从文件指定偏移量开始执行`read/write`

调用`pread`相当于先调用`lseek`再调用`read`.但是调用`pread`时，无法中断其定位和读操作，并且不更新当前文件偏移量

调用`pwrite`相当于先调用`lseek`再调用`write`.但是调用`pwrite`时，无法中断其定位和写操作，并且不更新当前文件偏移量

<br>

## 5.数据同步

UNIX操作系统在内核中设有**缓冲区高速缓存**或**页高速缓存**，大多数磁盘 I/O 都通过缓冲区进行。当我们想文件写入数据时，内核通常都先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式称为**延迟写**

以下2种情况会将缓冲区中的数据写回到磁盘：

- 当内核需要重用缓冲区来存方其他数据时，它会把所有延迟写的数据库写入磁盘
- 可以调用`sync`、`fsync`或`fdatasync`来显式的将所有延迟写的数据块写回磁盘

<div align="center"> <img src="../pic/apue-fileio-12.png"/> </div>

* 参数（前两个函数）：
    * `fd`：指定写回的文件

3个函数的区别：

- `sync`（`update` 守护进程会周期性(一般每隔30s)的调用`sync`函数。命令`sync`也会调用`sync`函数）：
    + 将所有修改过的块缓冲区排入写队列，然后返回
    + 它并不等待实际写磁盘操作结束
- `fsync`：
    + 只对由`fd`指定的单个文件起作用
    + 等待写磁盘操作结束才返回
- `fdatasync`：
    + 只对由`fd`指定的单个文件起作用，但是它只影响文件的数据部分（`fsync`会同步更新文件的属性）
    + 等待写磁盘操作结束才返回

<br>
<br>

# 二.文件和目录

<br>
<br>

# 三.标准I/O库

标准I/O库处理很多细节，如缓冲区分片、以优化的块长度执行I/O等。这些处理使用户不必担心如何选择使用正确的块长度。这使得它便于用户使用，但是如果不深入了解I/O库函数的操作，也会带来一些问题

## 1.流

标准I/O库与文件I/O区别：

- 标准I/O库处理很多细节，如缓冲区分片、以优化的块长度执行I/O等
- 文件I/O函数都是**围绕文件描述符**进行。首先打开一个文件，返回一个文件描述符；后续的文件IO操作都使用该文件描述符
- 标准I/O库是**围绕流**进行的

**当用标准I/O库打开或者创建一个文件时，就有一个内建的流与之相关联**

### 1.1 流的定向

> 流的定向决定了所处理的字符是单字节还是多字节的

对于ASCII字符集，一个字符用一个字节表示；对于国际字符集，一个字符可以用多个字节表示。标准I/O文件流可用于单字节或者多字节字符集。**流的定向**决定了所处理的字符是单字节还是多字节的

- 当一个流最初被创建时，它并没有定向
    - 若在未定向的流上使用一个多字节I/O函数，则将该流的定向设置为宽定向的（即处理多字节）
    - 若在未定向的流上使用一个单字节I/O函数，则将该流的定向设置为字节定向的（即处理单字节）
- 只有两个函数可以改变流的定向
    - `freopen`：清除一个流的定向
    - `fwide`：设置流的定向（并不改变已定向流的定向）

<div align="center"> <img src="../pic/apue-standardio-1.png"/> </div>

* 参数：
    * `fp`：`FILE`文件对象的指针
    * `mode`：流的定向模式。
        * 如果`mode`是**负数**，则函数试图使指定的流为**字节定向**（不保证成功，因为`fwide`不改变已定向流的定向）
        * 如果`mode`是**正数**，则函数试图使指定的流为**宽定向**的（不保证成功，因为`fwide`不改变已定向流的定向）
        * 如果`mode`为0，则函数不试图设置流的定向，而直接返回该流定向的值（可以用以获取流的定向）

注意：如果`fp`是无效流，由于`fwide`从返回值无法得知函数执行成功还是失败。那么我们必须采用这个方法：首先在调用`fwide`之前清除`errno`。然后在`fwide`之后检查`errno`的值。通过`errno`来检测`fwide`执行成功还是失败

### 1.2 3个标准流

操作系统对每个进程与定义了3个流，并且这3个流可以自动地被进程使用，他们都是定义在`<stdio.h>`中：

- **标准输入**：预定义的文件指针(FILE对象)为`stdin`，它内部的文件描述符就是`STDIN_FILENO`
- **标准输出**：预定义的文件指针(FILE对象)为`stdout`，它内部的文件描述符就是`STDOUT_FILENO`
- **标准错误**：预定义的文件指针(FILE对象)为`stderr`，它内部的文件描述符就是`STDERR_FILENO`

<br>

## 2.FILE对象

当使用`fopen`函数打开一个流时，它返回一个指向`FILE`对象的指针（书中称作**文件指针**）。该对象通常是一个结构，包含了标准I/O库为管理该流所需要的所有信息，包括：

* 用于实际I/O的文件描述符
* 指向用于该流缓冲区的指针
* 该流缓冲区的长度
* 当前在缓冲区中的字符数
* 出错标志

应用程序没必要检验`FILE`对象，只需要将`FILE`指针作为参数传递给每个标准I/O函数

<br>

## 3.缓冲

标准IO库提供缓冲的目的是：尽量减少使用`read`和`write`调用的次数。标准I/O库对每个I/O流自动地进行缓冲管理，从而避免了程序员需要手动管理这一点带来的麻烦

### 3.1 3种缓冲类型

标准IO库提供了三种类型的缓冲：

- **全缓冲**：此时在标准I/O缓冲区被填满后，标准I/O库才进行实际的I/O操作
- **行缓冲**：此时当输入和输出中遇到换行符时，标准IO库执行实际的I/O操作。但是注意：
    - 只要填满了缓冲区，即使还没有写一个换行符，也立即进行I/O操作
    - 任何时候只要通过标准I/O库，从一个不带缓冲的流或者一个行缓冲的流得到输入数据，则会冲洗所有行缓冲输出流。(<font color='red'>即要缓冲输入，先冲洗输出缓冲</font>)
- **不带缓冲**：标准I/O库不进行缓冲。此时任何I/O都立即执行实际的I/O操作

在一个流上执行第一次I/O操作时，相关标准的I/O函数通常调用 malloc 获取使用的缓冲区

下列函数可以**设置流的缓存类型**：

<div align="center"> <img src="../pic/apue-standardio-2.png"/> </div>

* 参数：
    * `fp`：被打开的文件对象的指针
    * `buf`：指向缓冲区的指针（如果是setbuf，长度就是BUFSIZ，定义在`<stdio.h>`中）
    * `mode`：指定缓冲类型。可以为：
        * `_IOFBF`：全缓冲。
        * `_IOLBF`：行缓冲
        * `_IONBF`：不带缓冲。此时忽略`buf`和`size`参数
    * `size`：缓冲的长度

<div align="center"> <img src="../pic/apue-standardio-3.png"/> </div>

注意：

- 如果在一个函数内分配一个自动变量类型的标准I/O缓冲区，则从该函数返回之前，必须关闭流。因此自动变量是栈上分配，函数返回之后自动变量被销毁
- 某些操作系统将缓冲区的一部分存放它自己的管理操作信息，因此可以存放在缓冲区中的实际数据字节数将少于`size`
- 通常推荐利用操作系统自动选择缓冲区长度并自动分配缓冲区。在这种情况下若关闭此流，则标准IO库会自动释放缓冲区

### 3.2 缓冲区冲洗

* 缓冲区可以由标准的IO操作自动地冲洗（如，当填满一个缓冲区时）
* 也可以手动调用fflush函数冲洗一个流

<div align="center"> <img src="../pic/apue-standardio-4.png"/> </div>

* 参数：
    * `fp`：被打开的文件对象的指针（`fp`为`NULL`时，此函数将导致所有输出流被冲洗）

冲洗是双向的：1）输出流 ---> 内核 ---> 磁盘或者终端； 2）输入流---> 用户缓冲区

冲洗并不是立即写到磁盘文件中。冲洗只是负责数据传到内核

### 3.3 标准流与缓冲

- **标准输入与标准输出**
    + 默认情况下，1）若是指向终端设备的流，则是**行缓冲**的；2）否则是**全缓冲**的
- **标准错误**
    + 默认情况下，是**不带缓冲**的
    + 不会是全缓冲

<br>

## 4.相关调用

### 4.1 打开流

<div align="center"> <img src="../pic/apue-standardio-5.png"/> </div>

- 参数：
    + `type`：指定对该IO流的读写方式（具体见下图）
        * 其中`b`用于区分二进制文件和文本文件。但是由于`UNIX`内核并不区分这两种文件，所以在UNIX环境中指定`b`并没有什么用
        * 对于`fdopen`，`type`意义稍微有点区别。因为该描述符已经被打开，所以`fdopen`为写而打开并不截断该文件。另外该文件既然被打开并返回一个文件描述符，则它一定存在。因此标准I/O追加写方式也不能创建文件
    + `pathname`：待打开文件的路径名
    + `fp`：指定的流（若`fp`已经打开，则先关闭该流；若`fp`已经定向，则清除该定向）
    + `fd`：指定的文件描述符。获得的标准I/O流将与该描述符结合

<div align="center"> <img src="../pic/apue-standardio-6.png"/> </div>

这几个函数的常见用途：

- `fopen`常用于打开一个指定的文件，返回一个文件指针
- `freopen`常用于在一个指定的流（标准输入、标准输出或者标准错误）上，打开一个指定的文件
- `fdopen`常用于将文件描述符包装成一个标准I/O流。因为某些特殊类型的文件（如管道、`socket`文件）不能用`fopen`打开，必须先获取文件描述符，然后对文件描述符调用`fdopen`

注意：当以读和写类型打开一个文件时(`type`中带`+`号的类型)，有下列限制：

- 如果写操作后面没有`fflush,fseek,fsetpos,rewind`操作之一，则写操作后面不能紧跟读操作
- 如果读操作后面没有`fseek,fsetpos,rewind`操作之一，也没有到达文件末尾，则在读操作之后不能紧跟写操作

**默认情况下，流被打开时是全缓冲的。但是如果流引用的是终端设备，则流被打开时是行缓冲的**

### 4.2 关闭流

<div align="center"> <img src="../pic/apue-standardio-7.png"/> </div>

* 参数：
    * `fp`：待关闭的文件指针

* 在该文件被关闭之前：
    + `fclose`会自动冲洗缓冲中的输出数据，缓冲区中的任何输入数据被丢弃
    + 若该缓冲区是标准I/O库自动分配的，则释放此缓冲区
* 当一个进程正常终止时（直接调用`exit`函数，或者从`main`函数返回）：
    + 所有带未写缓存数据的标准I/O流都被冲洗
    + 所有打开的标准I/O流都被关闭

<br>
<br>

# 四.进程环境

<br>
<br>

# 五.进程控制

<br>
<br>

# 六.进程关系

<br>
<br>

# 七.信号

<br>
<br>

# 八.线程

<br>
<br>

# 九.线程控制

<br>
<br>

# 十.进程间通信

<br>
<br>